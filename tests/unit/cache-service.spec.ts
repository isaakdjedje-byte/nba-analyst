/**
 * Cache Service Unit Tests
 * Tests for cache-service.ts - Cache-aside pattern implementation
 *
 * Generated by BMAD testarch-automate workflow
 * Priority: P1 (High) - Cache is critical infrastructure
 */

import { test, expect, beforeEach, afterEach, describe, vi } from 'vitest';
import { CacheService, CacheOptions } from '../../src/server/cache/cache-service';

// Mock Redis client for testing
const createMockRedisClient = () => {
  const store = new Map<string, { value: string; expiry: number }>();
  
  return {
    get: async (key: string) => {
      const item = store.get(key);
      if (!item) return null;
      if (item.expiry && item.expiry < Date.now()) {
        store.delete(key);
        return null;
      }
      return item.value;
    },
    setEx: async (key: string, ttl: number, value: string) => {
      store.set(key, { value, expiry: Date.now() + ttl * 1000 });
      return true;
    },
    del: async (key: string) => {
      const existed = store.has(key);
      store.delete(key);
      return existed ? 1 : 0;
    },
    exists: async (key: string) => {
      const item = store.get(key);
      if (!item) return 0;
      if (item.expiry && item.expiry < Date.now()) {
        store.delete(key);
        return 0;
      }
      return 1;
    },
    expire: async (key: string, ttl: number) => {
      const item = store.get(key);
      if (!item) return false;
      item.expiry = Date.now() + ttl * 1000;
      return true;
    },
    ttl: async (key: string) => {
      const item = store.get(key);
      if (!item) return -1;
      if (item.expiry && item.expiry < Date.now()) {
        store.delete(key);
        return -1;
      }
      return item.expiry ? Math.floor((item.expiry - Date.now()) / 1000) : -2;
    },
    scan: async (cursor: number, options: { MATCH: string; COUNT: number }) => {
      const keys = Array.from(store.keys()).filter(k => 
        k.includes(options.MATCH.replace('*', ''))
      );
      return [0, keys];
    },
    _store: store,
  };
};

describe('CacheService - Core Functionality @unit @cache @p1', () => {
  let cacheService: CacheService;
  let mockClient: ReturnType<typeof createMockRedisClient>;

  beforeEach(() => {
    vi.spyOn(console, 'error').mockImplementation(() => undefined);
    vi.spyOn(console, 'warn').mockImplementation(() => undefined);
    vi.stubEnv('REDIS_URL', 'redis://localhost:6379');
    mockClient = createMockRedisClient();
    cacheService = new CacheService(60);
    // @ts-expect-error - Inject mock client for testing
    cacheService.client = mockClient;
  });

  afterEach(() => {
    vi.restoreAllMocks();
    vi.unstubAllEnvs();
  });

  describe('getOrFetch - Cache-Aside Pattern', () => {
    test('[P0] should return cached data on cache hit', async () => {
      // Given cached data exists
      await mockClient.setEx('test-key', 60, JSON.stringify({ cached: true }));
      
      const fetcher = async () => ({ fetched: true });

      // When getting data
      const result = await cacheService.getOrFetch('test-key', fetcher);

      // Then should return cached data
      expect(result.fromCache).toBe(true);
      expect(result.data).toEqual({ cached: true });
    });

    test('[P0] should fetch data on cache miss', async () => {
      // Given no cached data
      const fetcher = async () => ({ fetched: true });

      // When getting data
      const result = await cacheService.getOrFetch('new-key', fetcher);

      // Then should fetch and cache data
      expect(result.fromCache).toBe(false);
      expect(result.data).toEqual({ fetched: true });
      
      // Verify data was cached
      const cached = await mockClient.get('new-key');
      expect(cached).toBe(JSON.stringify({ fetched: true }));
    });

    test('[P0] should handle fetcher errors gracefully', async () => {
      // Given a fetcher that throws
      const fetcher = async () => {
        throw new Error('Database error');
      };

      // When getting data
      const result = await cacheService.getOrFetch('error-key', fetcher);

      // Then should return error in result
      expect(result.data).toBeNull();
      expect(result.error).toBe('Database error');
    });

    test('[P1] should respect skipCache option', async () => {
      // Given cached data exists
      await mockClient.setEx('cached-key', 60, JSON.stringify({ cached: true }));
      
      const fetcher = async () => ({ fetched: true });
      const options: CacheOptions = { skipCache: true };

      // When getting data with skipCache
      const result = await cacheService.getOrFetch('cached-key', fetcher, options);

      // Then should fetch fresh data, ignoring cache
      expect(result.fromCache).toBe(false);
      expect(result.data).toEqual({ fetched: true });
    });

    test('[P1] should use custom TTL from options', async () => {
      // Given a fetcher
      const fetcher = async () => ({ data: 'test' });
      const options: CacheOptions = { ttl: 120 };

      // When getting data with custom TTL
      await cacheService.getOrFetch('ttl-test', fetcher, options);

      // Then data should be cached with custom TTL
      const ttl = await mockClient.ttl('ttl-test');
      expect(ttl).toBeGreaterThanOrEqual(119);
      expect(ttl).toBeLessThanOrEqual(120);
    });

    test('[P2] should handle invalid JSON in cache', async () => {
      // Given invalid JSON in cache
      mockClient._store.set('invalid-json', { value: 'not-json', expiry: Date.now() + 60000 });
      
      const fetcher = async () => ({ fetched: true });

      // When getting data
      const result = await cacheService.getOrFetch('invalid-json', fetcher);

      // Then should fetch fresh data
      expect(result.fromCache).toBe(false);
      expect(result.data).toEqual({ fetched: true });
    });
  });

  describe('get - Direct Cache Access', () => {
    test('[P1] should return cached data', async () => {
      // Given cached data
      await mockClient.setEx('get-key', 60, JSON.stringify({ value: 'test' }));

      // When getting directly from cache
      const result = await cacheService.get<{ value: string }>('get-key');

      // Then should return cached data
      expect(result).toEqual({ value: 'test' });
    });

    test('[P1] should return null for missing key', async () => {
      // Given no cached data

      // When getting missing key
      const result = await cacheService.get('missing-key');

      // Then should return null
      expect(result).toBeNull();
    });
  });

  describe('set - Cache Storage', () => {
    test('[P0] should store data in cache', async () => {
      // Given data to cache

      // When setting cache
      const success = await cacheService.set('set-key', { stored: true }, 60);

      // Then should succeed
      expect(success).toBe(true);
      
      // And data should be retrievable
      const cached = await mockClient.get('set-key');
      expect(cached).toBe(JSON.stringify({ stored: true }));
    });

    test('[P1] should use default TTL when not specified', async () => {
      // Given data to cache
      cacheService = new CacheService(300); // 5 min default
      // @ts-expect-error - Inject mock client for testing
      cacheService.client = mockClient;

      // When setting cache
      await cacheService.set('ttl-key', { data: 'test' });

      // Then should use default TTL
      const ttl = await mockClient.ttl('ttl-key');
      expect(ttl).toBeGreaterThanOrEqual(299);
    });
  });

  describe('delete - Cache Invalidation', () => {
    test('[P0] should delete single key', async () => {
      // Given cached data
      await mockClient.setEx('delete-key', 60, JSON.stringify({ data: 'test' }));

      // When deleting key
      const success = await cacheService.delete('delete-key');

      // Then should succeed
      expect(success).toBe(true);
      
      // And key should be gone
      const exists = await mockClient.exists('delete-key');
      expect(exists).toBe(0);
    });

    test('[P1] should delete multiple keys', async () => {
      // Given multiple cached keys
      await mockClient.setEx('multi-1', 60, 'value1');
      await mockClient.setEx('multi-2', 60, 'value2');

      // When deleting multiple keys
      const success = await cacheService.deleteMany(['multi-1', 'multi-2']);

      // Then should succeed
      expect(success).toBe(true);
    });

    test('[P2] should delete keys by pattern', async () => {
      // Given keys with pattern
      await mockClient.setEx('pattern:1', 60, 'val1');
      await mockClient.setEx('pattern:2', 60, 'val2');
      await mockClient.setEx('other:1', 60, 'other');

      // When deleting by pattern
      const deleted = await cacheService.deleteByPattern('pattern:*');

      // Then should delete matching keys
      expect(deleted).toBe(2);
      
      // And other keys should remain
      expect(await mockClient.exists('other:1')).toBe(1);
    });
  });

  describe('exists - Cache Check', () => {
    test('[P1] should return true for existing key', async () => {
      // Given cached data
      await mockClient.setEx('exists-key', 60, 'value');

      // When checking existence
      const result = await cacheService.exists('exists-key');

      // Then should return true
      expect(result).toBe(true);
    });

    test('[P1] should return false for missing key', async () => {
      // When checking missing key
      const result = await cacheService.exists('missing-key');

      // Then should return false
      expect(result).toBe(false);
    });
  });

  describe('TTL Operations', () => {
    test('[P2] should set TTL on existing key', async () => {
      // Given cached data
      await mockClient.setEx('expire-key', 60, 'value');

      // When setting new TTL
      const success = await cacheService.expire('expire-key', 300);

      // Then should succeed
      expect(success).toBe(true);
      
      // And TTL should be updated
      const ttl = await mockClient.ttl('expire-key');
      expect(ttl).toBeGreaterThanOrEqual(299);
    });

    test('[P2] should get TTL for key', async () => {
      // Given cached data with known TTL
      await mockClient.setEx('ttl-key', 120, 'value');

      // When getting TTL
      const ttl = await cacheService.getTTL('ttl-key');

      // Then should return TTL in seconds
      expect(ttl).toBeGreaterThanOrEqual(119);
      expect(ttl).toBeLessThanOrEqual(120);
    });
  });
});

describe('CacheService - Graceful Degradation @unit @cache @p2', () => {
  test('[P1] should work without Redis configured', async () => {
    // Given cache service without Redis client
    const cacheService = new CacheService(60);
    // @ts-expect-error - No client for testing
    cacheService.client = null;
    
    const fetcher = async () => ({ fetched: true });

    // When getting data
    const result = await cacheService.getOrFetch('no-redis-key', fetcher);

    // Then should still fetch data (degraded gracefully)
    expect(result.fromCache).toBe(false);
    expect(result.data).toEqual({ fetched: true });
  });
});
