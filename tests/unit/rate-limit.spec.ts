/**
 * Rate Limiting Unit Tests
 * Tests for authentication rate limiting functionality
 *
 * Generated by BMAD testarch-automate workflow
 * Priority: P1 (High)
 */

import { test, expect, describe, beforeEach } from 'vitest';
import { rateLimit, resetRateLimit } from '../../src/server/auth/rate-limit';

describe('Rate Limiting - Basic Functionality @unit @rate-limit @security', () => {
  const testIdentifier = 'test-user-123';

  beforeEach(() => {
    // Reset rate limit before each test
    resetRateLimit(testIdentifier);
  });

  test('[P0] should allow first request', () => {
    // Given clean slate (reset in beforeEach)

    // When making first request
    const result = rateLimit(testIdentifier);

    // Then should be allowed
    expect(result.success).toBe(true);
    expect(result.retryAfter).toBeUndefined();
  });

  test('[P0] should track request count', () => {
    // Given first request
    rateLimit(testIdentifier);

    // When making additional requests (within limit)
    const result2 = rateLimit(testIdentifier);
    const result3 = rateLimit(testIdentifier);

    // Then should still be allowed
    expect(result2.success).toBe(true);
    expect(result3.success).toBe(true);
  });

  test('[P0] should block after exceeding max requests', () => {
    // Given max requests made (default is 5)
    for (let i = 0; i < 5; i++) {
      rateLimit(testIdentifier);
    }

    // When making request over limit
    const result = rateLimit(testIdentifier);

    // Then should be blocked
    expect(result.success).toBe(false);
    expect(result.retryAfter).toBeDefined();
    expect(result.retryAfter).toBeGreaterThan(0);
  });

  test('[P1] should reset after window expires', () => {
    // Given blocked user
    for (let i = 0; i < 5; i++) {
      rateLimit(testIdentifier);
    }
    const blockedResult = rateLimit(testIdentifier);
    expect(blockedResult.success).toBe(false);

    // When resetting rate limit
    resetRateLimit(testIdentifier);

    // Then should be allowed again
    const result = rateLimit(testIdentifier);
    expect(result.success).toBe(true);
  });

  test('[P1] should handle different identifiers independently', () => {
    // Given two different users
    const user1 = 'user-1';
    const user2 = 'user-2';

    // When user1 exceeds limit
    for (let i = 0; i < 5; i++) {
      rateLimit(user1);
    }

    // Then user1 should be blocked
    expect(rateLimit(user1).success).toBe(false);

    // But user2 should still be allowed
    expect(rateLimit(user2).success).toBe(true);
  });

  test('[P2] should provide retry after time when blocked', () => {
    // Given blocked user
    for (let i = 0; i < 5; i++) {
      rateLimit(testIdentifier);
    }

    // When getting rate limit result
    const result = rateLimit(testIdentifier);

    // Then should provide retry time (in seconds)
    expect(result.success).toBe(false);
    expect(result.retryAfter).toBeDefined();
    expect(typeof result.retryAfter).toBe('number');
    expect(result.retryAfter).toBeLessThanOrEqual(15 * 60); // Max 15 minutes
  });

  test('[P2] should handle custom configuration', () => {
    // Given custom config: 2 requests per 1 second
    const customConfig = {
      windowMs: 1000, // 1 second
      maxRequests: 2,
    };

    // When making requests within custom limit
    const result1 = rateLimit('custom-test', customConfig);
    const result2 = rateLimit('custom-test', customConfig);
    const result3 = rateLimit('custom-test', customConfig);

    // Then first two should pass, third should fail
    expect(result1.success).toBe(true);
    expect(result2.success).toBe(true);
    expect(result3.success).toBe(false);
  });

  test('[P2] should increment count on each successful request', () => {
    const results = [
      rateLimit(testIdentifier),
      rateLimit(testIdentifier),
      rateLimit(testIdentifier),
    ];

    expect(results.every((r) => r.success)).toBe(true);
  });

  test('[P3] should handle many different identifiers', () => {
    // Given many different users
    const users = Array.from({ length: 100 }, (_, i) => `user-${i}`);
    users.forEach((user) => resetRateLimit(user));

    // When each makes a request
    const results = users.map((user) => rateLimit(user));

    // Then all should be allowed
    expect(results.every((r) => r.success)).toBe(true);
  });

  test('[P3] should maintain state across multiple calls', () => {
    // Given multiple requests
    const results = [];
    for (let i = 0; i < 7; i++) {
      results.push(rateLimit(testIdentifier));
    }

    // Then first 5 should pass, rest should fail
    expect(results[0].success).toBe(true);
    expect(results[4].success).toBe(true);
    expect(results[5].success).toBe(false);
    expect(results[6].success).toBe(false);
  });
});

describe('Rate Limiting - Edge Cases @unit @rate-limit @edge-cases', () => {
  test('[P2] should handle empty identifier', () => {
    // When using empty identifier
    const result = rateLimit('');

    // Then should handle gracefully
    expect(result).toBeDefined();
  });

  test('[P2] should handle very long identifier', () => {
    // Given very long identifier
    const longId = 'a'.repeat(1000);

    // When checking rate limit
    const result = rateLimit(longId);

    // Then should handle gracefully
    expect(result.success).toBe(true);
  });

  test('[P2] should handle special characters in identifier', () => {
    // Given identifier with special characters
    const specialId = 'user@example.com:path/with/slashes';

    // When checking rate limit
    const result = rateLimit(specialId);

    // Then should handle gracefully
    expect(result.success).toBe(true);
  });

  test('[P3] should handle concurrent access simulation', () => {
    // Given single identifier
    const id = 'concurrent-test';

    // When simulating concurrent access
    const results = [];
    for (let i = 0; i < 10; i++) {
      results.push(rateLimit(id));
    }

    // Then should process all (first 5 allowed)
    const allowedCount = results.filter((r) => r.success).length;
    const blockedCount = results.filter((r) => !r.success).length;

    expect(allowedCount).toBe(5);
    expect(blockedCount).toBe(5);
  });
});
