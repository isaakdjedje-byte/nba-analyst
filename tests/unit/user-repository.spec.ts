/**
 * User Repository Unit Tests
 * Tests for user-repository.ts - Database operations for user management
 *
 * Generated by BMAD testarch-automate workflow
 * Priority: P0 (Critical) - User management is core functionality
 */

import { test, expect, describe, beforeEach } from 'vitest';
import { UserRole } from '../../src/server/auth/rbac';

// Mock Prisma client
interface MockUser {
  id: string;
  email: string;
  name: string | null;
  role: UserRole;
  createdAt: Date;
  updatedAt: Date;
}

const createMockPrisma = () => {
  const users: MockUser[] = [
    {
      id: 'user-1',
      email: 'admin@example.com',
      name: 'Admin User',
      role: UserRole.ADMIN,
      createdAt: new Date(),
      updatedAt: new Date(),
    },
    {
      id: 'user-2',
      email: 'user@example.com',
      name: 'Regular User',
      role: UserRole.USER,
      createdAt: new Date(),
      updatedAt: new Date(),
    },
  ];

  return {
    user: {
      findMany: async ({ where, orderBy, take, skip, select }: {
        where?: Record<string, unknown>;
        orderBy?: Record<string, string>;
        take?: number;
        skip?: number;
        select: Record<string, boolean>;
      }) => {
        let filtered = [...users];
        
        // Apply role filter
        if (where?.role) {
          filtered = filtered.filter(u => u.role === where.role);
        }
        
        // Apply search filter
        if (where?.OR) {
          const orClause = where.OR as Array<Record<string, { contains: string; mode: string }>>;
          filtered = filtered.filter(u => 
            orClause.some(clause => {
              if (clause.email?.contains) {
                return u.email.toLowerCase().includes(clause.email.contains.toLowerCase());
              }
              if (clause.name?.contains) {
                return u.name?.toLowerCase().includes(clause.name.contains.toLowerCase());
              }
              return false;
            })
          );
        }
        
        // Apply ordering
        if (orderBy?.createdAt) {
          filtered.sort((a, b) => 
            orderBy.createdAt === 'desc' 
              ? b.createdAt.getTime() - a.createdAt.getTime()
              : a.createdAt.getTime() - b.createdAt.getTime()
          );
        }
        
        // Apply pagination
        const start = skip || 0;
        const end = start + (take || 50);
        const paginated = filtered.slice(start, end);
        
        // Apply select
        return paginated.map(u => {
          const selected: Record<string, unknown> = {};
          for (const key of Object.keys(select)) {
            selected[key] = u[key as keyof MockUser];
          }
          return selected;
        });
      },
      
      findUnique: async ({ where }: { where: { id?: string; email?: string } }) => {
        if (where.id) {
          return users.find(u => u.id === where.id) || null;
        }
        if (where.email) {
          return users.find(u => u.email === where.email) || null;
        }
        return null;
      },
      
      count: async ({ where }: { where?: Record<string, unknown> }) => {
        let filtered = [...users];
        
        if (where?.role) {
          filtered = filtered.filter(u => u.role === where.role);
        }
        
        if (where?.OR) {
          const orClause = where.OR as Array<Record<string, { contains: string; mode: string }>>;
          filtered = filtered.filter(u => 
            orClause.some(clause => {
              if (clause.email?.contains) {
                return u.email.toLowerCase().includes(clause.email.contains.toLowerCase());
              }
              if (clause.name?.contains) {
                return u.name?.toLowerCase().includes(clause.name.contains.toLowerCase());
              }
              return false;
            })
          );
        }
        
        return filtered.length;
      },
      
      update: async ({ where, data }: { where: { id: string }; data: Partial<MockUser> }) => {
        const index = users.findIndex(u => u.id === where.id);
        if (index < 0) return null;
        
        users[index] = { ...users[index], ...data, updatedAt: new Date() };
        return users[index];
      },
      
      groupBy: async ({ by }: { by: string[] }) => {
        const groups: Record<string, number> = {};
        
        for (const user of users) {
          const role = user.role;
          groups[role] = (groups[role] || 0) + 1;
        }
        
        return Object.entries(groups).map(([role, _count]) => ({
          role,
          _count: { role: _count },
        }));
      },
    },
    // Test helpers
    _addUser: (user: MockUser) => users.push(user),
    _getUsers: () => users,
  };
};

describe('User Repository - Core Operations @unit @user-repo @p0', () => {
  let mockPrisma: ReturnType<typeof createMockPrisma>;

  beforeEach(() => {
    mockPrisma = createMockPrisma();
  });

  describe('getUsers - List Users', () => {
    test('[P0] should return all users without filters', async () => {
      // When getting all users
      const result = await mockPrisma.user.findMany({
        where: {},
        orderBy: { createdAt: 'desc' },
        take: 50,
        skip: 0,
        select: { id: true, email: true, name: true, role: true, createdAt: true, updatedAt: true },
      });

      // Then should return all users
      expect(result.length).toBe(2);
    });

    test('[P0] should filter users by role', async () => {
      // When filtering by admin role
      const result = await mockPrisma.user.findMany({
        where: { role: UserRole.ADMIN },
        orderBy: { createdAt: 'desc' },
        take: 50,
        skip: 0,
        select: { id: true, email: true, role: true },
      });

      // Then should return only admins
      expect(result.length).toBe(1);
      expect(result[0].role).toBe(UserRole.ADMIN);
    });

    test('[P1] should search users by email', async () => {
      // When searching by email
      const result = await mockPrisma.user.findMany({
        where: {
          OR: [
            { email: { contains: 'admin', mode: 'insensitive' } },
            { name: { contains: 'admin', mode: 'insensitive' } },
          ],
        },
        orderBy: { createdAt: 'desc' },
        take: 50,
        skip: 0,
        select: { id: true, email: true, name: true },
      });

      // Then should return matching users
      expect(result.length).toBe(1);
      expect(result[0].email).toContain('admin');
    });

    test('[P1] should support pagination', async () => {
      // Given more users
      mockPrisma._addUser({
        id: 'user-3',
        email: 'user3@example.com',
        name: 'User Three',
        role: UserRole.USER,
        createdAt: new Date(),
        updatedAt: new Date(),
      });

      // When getting first page
      const result = await mockPrisma.user.findMany({
        where: {},
        orderBy: { createdAt: 'desc' },
        take: 2,
        skip: 0,
        select: { id: true, email: true },
      });

      // Then should return limited results
      expect(result.length).toBe(2);
    });

    test('[P2] should return total count', async () => {
      // When getting count
      const count = await mockPrisma.user.count({ where: {} });

      // Then should return total
      expect(count).toBe(2);
    });
  });

  describe('getUserById - Get Single User', () => {
    test('[P0] should return user by ID', async () => {
      // When getting user by ID
      const result = await mockPrisma.user.findUnique({
        where: { id: 'user-1' },
      });

      // Then should return user
      expect(result).not.toBeNull();
      expect(result?.id).toBe('user-1');
      expect(result?.email).toBe('admin@example.com');
    });

    test('[P0] should return null for non-existent user', async () => {
      // When getting non-existent user
      const result = await mockPrisma.user.findUnique({
        where: { id: 'nonexistent' },
      });

      // Then should return null
      expect(result).toBeNull();
    });
  });

  describe('getUserByEmail - Get by Email', () => {
    test('[P0] should return user by email', async () => {
      // When getting user by email
      const result = await mockPrisma.user.findUnique({
        where: { email: 'user@example.com' },
      });

      // Then should return user
      expect(result).not.toBeNull();
      expect(result?.email).toBe('user@example.com');
    });

    test('[P1] should return null for unknown email', async () => {
      // When getting unknown email
      const result = await mockPrisma.user.findUnique({
        where: { email: 'unknown@example.com' },
      });

      // Then should return null
      expect(result).toBeNull();
    });
  });

  describe('updateUserRole - Role Management', () => {
    test('[P0] should update user role', async () => {
      // When updating role
      const result = await mockPrisma.user.update({
        where: { id: 'user-2' },
        data: { role: UserRole.ADMIN },
      });

      // Then should return updated user
      expect(result?.role).toBe(UserRole.ADMIN);
    });

    test('[P1] should return null for non-existent user', async () => {
      // When updating non-existent user
      const result = await mockPrisma.user.update({
        where: { id: 'nonexistent' },
        data: { role: UserRole.ADMIN },
      });

      // Then should return null
      expect(result).toBeNull();
    });
  });

  describe('userExists - User Existence Check', () => {
    test('[P0] should return true for existing user', async () => {
      // When checking existing user
      const user = await mockPrisma.user.findUnique({ where: { id: 'user-1' } });
      const exists = user !== null;

      // Then should return true
      expect(exists).toBe(true);
    });

    test('[P0] should return false for non-existent user', async () => {
      // When checking non-existent user
      const user = await mockPrisma.user.findUnique({ where: { id: 'nonexistent' } });
      const exists = user !== null;

      // Then should return false
      expect(exists).toBe(false);
    });
  });

  describe('countUsersByRole - Role Statistics', () => {
    test('[P1] should count users by role', async () => {
      // When counting by role
      const groups = await mockPrisma.user.groupBy({
        by: ['role'],
      });

      // Then should return counts per role
      const counts: Record<string, number> = {};
      for (const group of groups) {
        counts[group.role] = group._count.role;
      }

      expect(counts[UserRole.ADMIN]).toBe(1);
      expect(counts[UserRole.USER]).toBe(1);
    });

    test('[P2] should handle all role types', async () => {
      // When counting all roles
      const groups = await mockPrisma.user.groupBy({
        by: ['role'],
      });

      // Then should have entries for all role types
      const roles = groups.map(g => g.role);
      expect(roles).toContain(UserRole.ADMIN);
      expect(roles).toContain(UserRole.USER);
    });
  });
});

describe('User Repository - Edge Cases @unit @user-repo @p2', () => {
  let mockPrisma: ReturnType<typeof createMockPrisma>;

  beforeEach(() => {
    mockPrisma = createMockPrisma();
  });

  test('[P2] should handle empty search results', async () => {
    // When searching for non-existent
    const result = await mockPrisma.user.findMany({
      where: {
        OR: [
          { email: { contains: 'nonexistent', mode: 'insensitive' } },
          { name: { contains: 'nonexistent', mode: 'insensitive' } },
        ],
      },
      orderBy: { createdAt: 'desc' },
      take: 50,
      skip: 0,
      select: { id: true },
    });

    // Then should return empty array
    expect(result).toEqual([]);
  });

  test('[P2] should handle pagination beyond results', async () => {
    // When paginating beyond available
    const result = await mockPrisma.user.findMany({
      where: {},
      orderBy: { createdAt: 'desc' },
      take: 10,
      skip: 100,
      select: { id: true },
    });

    // Then should return empty array
    expect(result).toEqual([]);
  });

  test('[P2] should preserve user data on role update', async () => {
    // Given existing user
    const originalUser = await mockPrisma.user.findUnique({ 
      where: { id: 'user-1' } 
    });

    // When updating role only
    await mockPrisma.user.update({
      where: { id: 'user-1' },
      data: { role: UserRole.ADMIN },
    });

    // Then should preserve other fields
    const updatedUser = await mockPrisma.user.findUnique({ 
      where: { id: 'user-1' } 
    });
    
    expect(updatedUser?.email).toBe(originalUser?.email);
    expect(updatedUser?.name).toBe(originalUser?.name);
  });
});
