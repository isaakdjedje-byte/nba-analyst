/**
 * Test Helper Utilities
 * 
 * Common helper functions for Playwright tests
 * Generated by BMAD TEA (testarch-automate workflow)
 */

import { Page, Response, APIRequestContext, expect } from '@playwright/test';

/**
 * Wait for API response with optional status validation
 */
export async function waitForApiResponse(
  page: Page,
  urlPattern: string,
  options?: {
    status?: number;
    timeout?: number;
  }
): Promise<Response> {
  const response = await page.waitForResponse(
    (response) => 
      response.url().includes(urlPattern) && 
      (options?.status ? response.status() === options.status : response.ok()),
    { timeout: options?.timeout ?? 30000 }
  );
  return response;
}

/**
 * Wait for multiple API responses to complete
 */
export async function waitForApiResponses(
  page: Page,
  urlPatterns: string[],
  options?: { timeout?: number }
): Promise<Response[]> {
  const promises = urlPatterns.map((pattern) => 
    page.waitForResponse(
      (response) => response.url().includes(pattern) && response.ok(),
      { timeout: options?.timeout ?? 30000 }
    )
  );
  return Promise.all(promises);
}

/**
 * Mock API response for testing
 */
export async function mockApiResponse(
  page: Page,
  urlPattern: string,
  response: {
    status?: number;
    body?: unknown;
    headers?: Record<string, string>;
  }
): Promise<void> {
  await page.route(urlPattern, (route) => {
    route.fulfill({
      status: response.status ?? 200,
      body: response.body ? JSON.stringify(response.body) : undefined,
      headers: {
        'Content-Type': 'application/json',
        ...response.headers,
      },
    });
  });
}

/**
 * Fill and submit form with validation
 */
export async function fillAndSubmitForm(
  page: Page,
  fields: { selector: string; value: string }[],
  submitSelector: string
): Promise<void> {
  for (const field of fields) {
    await page.fill(field.selector, field.value);
  }
  await page.click(submitSelector);
}

/**
 * Assert element is visible with custom timeout
 */
export async function assertVisible(
  page: Page,
  selector: string,
  timeout = 5000
): Promise<void> {
  await expect(page.locator(selector)).toBeVisible({ timeout });
}

/**
 * Assert element contains text
 */
export async function assertContainsText(
  page: Page,
  selector: string,
  text: string
): Promise<void> {
  await expect(page.locator(selector)).toContainText(text);
}

/**
 * Navigate and wait for page load
 */
export async function navigateAndWait(
  page: Page,
  url: string,
  waitForSelector?: string
): Promise<void> {
  await page.goto(url);
  if (waitForSelector) {
    await expect(page.locator(waitForSelector)).toBeVisible({ timeout: 30000 });
  }
}

/**
 * Create authenticated page context
 */
export async function createAuthenticatedContext(
  page: Page,
  token: string
): Promise<void> {
  await page.addInitScript((authToken) => {
    window.localStorage.setItem('authToken', authToken);
    window.sessionStorage.setItem('authToken', authToken);
  }, token);
}

/**
 * Poll API until condition is met
 */
export async function pollUntil<T>(
  requestFn: () => Promise<T>,
  condition: (result: T) => boolean,
  options?: {
    interval?: number;
    timeout?: number;
  }
): Promise<T> {
  const interval = options?.interval ?? 2000;
  const timeout = options?.timeout ?? 30000;
  const startTime = Date.now();
  
  while (Date.now() - startTime < timeout) {
    const result = await requestFn();
    if (condition(result)) {
      return result;
    }
    await new Promise((resolve) => setTimeout(resolve, interval));
  }
  
  throw new Error(`Polling timed out after ${timeout}ms`);
}

/**
 * Generate test data using faker
 */
export const testData = {
  user: (overrides?: Record<string, unknown>) => ({
    id: crypto.randomUUID(),
    email: `test-${Date.now()}@example.com`,
    name: 'Test User',
    role: 'user',
    ...overrides,
  }),
  
  admin: (overrides?: Record<string, unknown>) => ({
    id: crypto.randomUUID(),
    email: `admin-${Date.now()}@example.com`,
    name: 'Admin User',
    role: 'admin',
    ...overrides,
  }),
  
  policyThreshold: (overrides?: Record<string, unknown>) => ({
    hardstopThreshold: 1000,
    driftThreshold: 0.1,
    confidenceThreshold: 0.7,
    edgeThreshold: 0.05,
    ...overrides,
  }),
  
  run: (overrides?: Record<string, unknown>) => ({
    id: crypto.randomUUID(),
    type: 'daily',
    status: 'pending',
    startedAt: new Date().toISOString(),
    ...overrides,
  }),
};

/**
 * Retry helper for flaky operations
 */
export async function retry<T>(
  fn: () => Promise<T>,
  options?: {
    maxAttempts?: number;
    delay?: number;
  }
): Promise<T> {
  const maxAttempts = options?.maxAttempts ?? 3;
  const delay = options?.delay ?? 1000;
  
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      return await fn();
    } catch (error) {
      if (attempt === maxAttempts) {
        throw error;
      }
      await new Promise((resolve) => setTimeout(resolve, delay * attempt));
    }
  }
  
  throw new Error('Retry failed');
}
