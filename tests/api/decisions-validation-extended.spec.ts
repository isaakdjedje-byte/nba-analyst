/**
 * Decisions API Extended Validation Tests
 * Additional edge cases for decision validation beyond existing coverage
 *
 * Generated by BMAD testarch-automate workflow
 * Priority: P1 (High) - Additional validation coverage
 */

import { test, expect } from '../support/merged-fixtures';
import { createDecision, createMatch } from '../support/factories';

test.describe('Decisions API Extended Validation - P1 @p1 @api @decisions @validation-extended', () => {
  const createdDecisionIds: string[] = [];

  test.afterEach(async ({ request }) => {
    // Cleanup: Delete all decisions created during test
    for (const decisionId of createdDecisionIds) {
      await request.delete(`/api/v1/decisions/${decisionId}`).catch(() => {});
    }
    createdDecisionIds.length = 0;
  });

  test('[P0] should reject decision with missing status', async ({ api }) => {
    // Given decision without status field
    const match = createMatch();
    const decision = {
      matchId: match.id,
      confidence: 0.85,
    };

    // When attempting to create
    const response = await api.post('/api/v1/decisions', { data: decision });

    // Then should return bad request
    expect(response.status()).toBe(400);
    const body = await response.json();
    expect(body.error).toBeDefined();
  });

  test('[P0] should reject decision with null status', async ({ api }) => {
    // Given decision with null status
    const match = createMatch();
    const decision = {
      matchId: match.id,
      status: null,
      confidence: 0.85,
    };

    // When attempting to create
    const response = await api.post('/api/v1/decisions', { data: decision });

    // Then should return bad request
    expect(response.status()).toBe(400);
  });

  test('[P1] should reject decision with empty string status', async ({ api }) => {
    // Given decision with empty string status
    const match = createMatch();
    const decision = {
      matchId: match.id,
      status: '',
      confidence: 0.85,
    };

    // When attempting to create
    const response = await api.post('/api/v1/decisions', { data: decision });

    // Then should return bad request
    expect(response.status()).toBe(400);
  });

  test('[P1] should reject decision with confidence exactly 0', async ({ api }) => {
    // Given a match
    const match = createMatch();

    // And decision with zero confidence
    const decision = createDecision({
      matchId: match.id,
      confidence: 0,
    });

    // When attempting to create
    const response = await api.post('/api/v1/decisions', { data: decision });

    // Then should return bad request (confidence must be > 0)
    expect(response.status()).toBe(400);
  });

  test('[P1] should reject decision with confidence exactly 1', async ({ api }) => {
    // Given a match
    const match = createMatch();

    // And decision with confidence exactly 1
    const decision = createDecision({
      matchId: match.id,
      confidence: 1.0,
    });

    // When attempting to create
    const response = await api.post('/api/v1/decisions', { data: decision });

    // Then should return bad request (confidence must be < 1)
    expect(response.status()).toBe(400);
  });

  test('[P2] should reject decision with extremely long rationale', async ({ api }) => {
    // Given a match
    const match = createMatch();

    // And decision with extremely long rationale (> 10000 chars)
    const longRationale = 'A'.repeat(10001);
    const decision = createDecision({
      matchId: match.id,
      rationale: longRationale,
    });

    // When attempting to create
    const response = await api.post('/api/v1/decisions', { data: decision });

    // Then should return bad request due to length validation
    expect(response.status()).toBe(400);
  });

  test('[P2] should reject decision with non-string rationale', async ({ api }) => {
    // Given a match
    const match = createMatch();

    // And decision with non-string rationale
    const decision = {
      matchId: match.id,
      status: 'Pick',
      rationale: 12345,
    };

    // When attempting to create
    const response = await api.post('/api/v1/decisions', { data: decision });

    // Then should return bad request
    expect(response.status()).toBe(400);
  });

  test('[P1] should reject decision with invalid matchId format', async ({ api }) => {
    // Given decision with invalid matchId format
    const decision = {
      matchId: 'not-a-valid-uuid',
      status: 'Pick',
      confidence: 0.85,
    };

    // When attempting to create
    const response = await api.post('/api/v1/decisions', { data: decision });

    // Then should return bad request
    expect(response.status()).toBe(400);
  });

  test('[P2] should reject decision with additional unknown fields', async ({ api }) => {
    // Given a match
    const match = createMatch();

    // And decision with unknown fields
    const decision = {
      matchId: match.id,
      status: 'Pick',
      confidence: 0.85,
      unknownField: 'should-be-rejected',
      anotherUnknown: 123,
    };

    // When attempting to create
    const response = await api.post('/api/v1/decisions', { data: decision });

    // Then should either reject (strict) or ignore (lenient)
    // Either 400 (strict) or 201 (lenient) is acceptable
    expect([400, 201]).toContain(response.status());
  });

  test('[P1] should create decision with Pick status', async ({ api }) => {
    // Given a match
    const match = createMatch();

    // And decision with Pick status
    const decision = createDecision({
      matchId: match.id,
      status: 'Pick',
    });

    // When creating via API
    const response = await api.post('/api/v1/decisions', { data: decision });

    // Then should be created successfully
    expect(response.status()).toBe(201);
    const created = await response.json();
    expect(created.id).toBeDefined();
    expect(created.status).toBe('Pick');

    // Track for cleanup
    createdDecisionIds.push(created.id);
  });

  test('[P1] should create decision with NoBet status', async ({ api }) => {
    // Given a match
    const match = createMatch();

    // And decision with NoBet status
    const decision = createDecision({
      matchId: match.id,
      status: 'No-Bet',
    });

    // When creating via API
    const response = await api.post('/api/v1/decisions', { data: decision });

    // Then should be created successfully
    expect(response.status()).toBe(201);
    const created = await response.json();
    expect(created.id).toBeDefined();
    expect(created.status).toBe('NoBet');

    // Track for cleanup
    createdDecisionIds.push(created.id);
  });

  test('[P2] should handle decision with maximum confidence (0.99)', async ({ api }) => {
    // Given a match
    const match = createMatch();

    // And decision with maximum valid confidence
    const decision = createDecision({
      matchId: match.id,
      confidence: 0.99,
    });

    // When creating via API
    const response = await api.post('/api/v1/decisions', { data: decision });

    // Then should be created successfully
    expect(response.status()).toBe(201);
    const created = await response.json();
    expect(created.confidence).toBe(0.99);

    // Track for cleanup
    createdDecisionIds.push(created.id);
  });

  test('[P2] should handle decision with minimum confidence (0.01)', async ({ api }) => {
    // Given a match
    const match = createMatch();

    // And decision with minimum valid confidence
    const decision = createDecision({
      matchId: match.id,
      confidence: 0.01,
    });

    // When creating via API
    const response = await api.post('/api/v1/decisions', { data: decision });

    // Then should be created successfully
    expect(response.status()).toBe(201);
    const created = await response.json();
    expect(created.confidence).toBe(0.01);

    // Track for cleanup
    createdDecisionIds.push(created.id);
  });

  test('[P2] should create decision with rationale containing special characters', async ({ api }) => {
    // Given a match
    const match = createMatch();

    // And decision with special characters in rationale
    const decision = createDecision({
      matchId: match.id,
      rationale: 'Strong pick! NBA odds look good. Odds: 2.5x, EV: +15%',
    });

    // When creating via API
    const response = await api.post('/api/v1/decisions', { data: decision });

    // Then should be created successfully
    expect(response.status()).toBe(201);
    const created = await response.json();
    expect(created.rationale).toContain('Strong pick!');

    // Track for cleanup
    createdDecisionIds.push(created.id);
  });

  test('[P2] should create decision with rationale containing unicode', async ({ api }) => {
    // Given a match
    const match = createMatch();

    // And decision with unicode in rationale
    const decision = createDecision({
      matchId: match.id,
      rationale: 'Great value! æ—¥æœ¬èªžãƒ†ã‚¹ãƒˆ Ã‰moji ðŸŽ¯',
    });

    // When creating via API
    const response = await api.post('/api/v1/decisions', { data: decision });

    // Then should be created successfully
    expect(response.status()).toBe(201);
    const created = await response.json();
    expect(created.rationale).toContain('æ—¥æœ¬èªžãƒ†ã‚¹ãƒˆ');

    // Track for cleanup
    createdDecisionIds.push(created.id);
  });
});
