/**
 * Runs Trigger API Tests
 * 
 * Coverage: Tests for /api/v1/runs/trigger endpoint
 * Priority: P1 - Critical daily run triggering functionality
 * 
 * Generated by: testarch-automate workflow
 */

import { test, expect } from '@playwright/test';
import { faker } from '@faker-js/faker';

test.describe('Runs Trigger API', () => {
  const BASE_URL = '/api/v1/runs/trigger';

  test.describe('Trigger Daily Run', () => {
    test('[P0] should trigger a new daily run', async ({ request }) => {
      // Given: Valid authentication
      // When: Triggering a new run
      const response = await request.post(BASE_URL, {
        headers: {
          'Authorization': `Bearer admin-token`,
          'Content-Type': 'application/json',
        },
        data: {
          run_type: 'daily',
          sport: 'NBA',
        },
      });

      // Then: Should return success
      expect([200, 201]).toContain(response.status());
      
      if ([200, 201].includes(response.status())) {
        const body = await response.json();
        expect(body).toHaveProperty('run_id');
        expect(body).toHaveProperty('status');
        expect(body.status).toBe('triggered');
      }
    });

    test('[P0] should require authentication to trigger run', async ({ request }) => {
      // Given: No authentication
      // When: Attempting to trigger without auth
      const response = await request.post(BASE_URL, {
        headers: {
          'Content-Type': 'application/json',
        },
        data: {
          run_type: 'daily',
        },
      });

      // Then: Should return 401
      expect(response.status()).toBe(401);
    });

    test('[P1] should validate run type parameter', async ({ request }) => {
      // Given: Invalid run type
      const response = await request.post(BASE_URL, {
        headers: {
          'Authorization': `Bearer admin-token`,
          'Content-Type': 'application/json',
        },
        data: {
          run_type: 'invalid_type',
        },
      });

      // Then: Should return 400 Bad Request
      expect(response.status()).toBe(400);
      
      const body = await response.json();
      expect(body).toHaveProperty('error');
    });

    test('[P1] should require admin privileges', async ({ request }) => {
      // Given: Non-admin user
      const response = await request.post(BASE_URL, {
        headers: {
          'Authorization': `Bearer user-token`,
          'Content-Type': 'application/json',
        },
        data: {
          run_type: 'daily',
        },
      });

      // Then: Should return 403 Forbidden
      expect(response.status()).toBe(403);
    });

    test('[P2] should support optional sport parameter', async ({ request }) => {
      // Given: Request with specific sport
      const response = await request.post(BASE_URL, {
        headers: {
          'Authorization': `Bearer admin-token`,
          'Content-Type': 'application/json',
        },
        data: {
          run_type: 'daily',
          sport: 'NBA',
        },
      });

      // Then: Should process sport parameter
      expect([200, 201, 400]).toContain(response.status());
    });

    test('[P2] should return run metadata on success', async ({ request }) => {
      // Given: Valid trigger request
      const response = await request.post(BASE_URL, {
        headers: {
          'Authorization': `Bearer admin-token`,
          'Content-Type': 'application/json',
        },
        data: {
          run_type: 'daily',
        },
      });

      // Then: Should include metadata
      if ([200, 201].includes(response.status())) {
        const body = await response.json();
        expect(body).toHaveProperty('run_id');
        expect(body).toHaveProperty('triggered_at');
        expect(body).toHaveProperty('estimated_duration');
      }
    });
  });

  test.describe('Run Status', () => {
    test('[P1] should check run status after trigger', async ({ request }) => {
      // Given: A triggered run
      const triggerResponse = await request.post(BASE_URL, {
        headers: {
          'Authorization': `Bearer admin-token`,
          'Content-Type': 'application/json',
        },
        data: { run_type: 'daily' },
      });

      if ([200, 201].includes(triggerResponse.status())) {
        const triggerBody = await triggerResponse.json();
        const runId = triggerBody.run_id;

        // When: Checking run status
        const statusResponse = await request.get(`/api/v1/runs/${runId}`, {
          headers: {
            'Authorization': `Bearer admin-token`,
          },
        });

        // Then: Should return run status
        expect([200, 404]).toContain(statusResponse.status());
      }
    });
  });

  test.describe('Run Scheduling', () => {
    test('[P1] should support scheduling runs for future time', async ({ request }) => {
      // Given: Schedule parameter
      const scheduledTime = new Date(Date.now() + 60 * 60 * 1000).toISOString(); // 1 hour from now
      
      const response = await request.post(BASE_URL, {
        headers: {
          'Authorization': `Bearer admin-token`,
          'Content-Type': 'application/json',
        },
        data: {
          run_type: 'daily',
          scheduled_for: scheduledTime,
        },
      });

      // Then: Should accept scheduled run
      expect([200, 201, 400]).toContain(response.status());
      
      if ([200, 201].includes(response.status())) {
        const body = await response.json();
        expect(body).toHaveProperty('scheduled');
      }
    });

    test('[P2] should validate scheduled time is in future', async ({ request }) => {
      // Given: Past time
      const pastTime = new Date(Date.now() - 60 * 60 * 1000).toISOString(); // 1 hour ago
      
      const response = await request.post(BASE_URL, {
        headers: {
          'Authorization': `Bearer admin-token`,
          'Content-Type': 'application/json',
        },
        data: {
          run_type: 'daily',
          scheduled_for: pastTime,
        },
      });

      // Then: Should return error
      expect(response.status()).toBe(400);
    });
  });
});
