import { test, expect } from '@playwright/test';

/**
 * Ingestion API Tests - Coverage Expansion
 * Generated by BMAD testarch-automate workflow
 *
 * Tags: @p0 @p1 @ingestion @data-pipeline @api
 */

test.describe('Ingestion API @ingestion @api', () => {
  const baseUrl = process.env.BASE_URL || 'http://localhost:3000';

  test.describe('POST /api/ingestion @p0', () => {
    test('[P0] should trigger data ingestion successfully', async ({ request }) => {
      const response = await request.post(`${baseUrl}/api/ingestion`, {
        data: {
          source: 'nba-api',
          date: new Date().toISOString().split('T')[0],
        },
      });

      expect([200, 202, 401]).toContain(response.status());
      if (response.status() === 200 || response.status() === 202) {
        const body = await response.json();
        expect(body.status).toBeDefined();
      }
    });

    test('[P1] should reject ingestion with invalid source', async ({ request }) => {
      const response = await request.post(`${baseUrl}/api/ingestion`, {
        data: {
          source: 'invalid-source',
          date: '2024-01-01',
        },
      });

      expect([400, 401, 422]).toContain(response.status());
    });

    test('[P2] should handle concurrent ingestion requests', async ({ request }) => {
      const requests = Array(3).fill(null).map(() =>
        request.post(`${baseUrl}/api/ingestion`, {
          data: { source: 'nba-api', date: '2024-01-01' },
        })
      );

      const responses = await Promise.all(requests);
      const statuses = responses.map(r => r.status());
      
      // All should complete (may be rate limited)
      statuses.forEach(status => {
        expect([200, 202, 401, 429]).toContain(status);
      });
    });
  });

  test.describe('GET /api/ingestion/health @p0', () => {
    test('[P0] should return ingestion system health status', async ({ request }) => {
      const response = await request.get(`${baseUrl}/api/ingestion/health`);

      expect([200, 401]).toContain(response.status());
      if (response.status() === 200) {
        const body = await response.json();
        expect(body.status).toBeDefined();
        expect(['healthy', 'degraded', 'unhealthy']).toContain(body.status);
      }
    });

    test('[P1] should include provider health details', async ({ request }) => {
      const response = await request.get(`${baseUrl}/api/ingestion/health`);

      if (response.status() === 200) {
        const body = await response.json();
        expect(body.providers).toBeDefined();
        expect(Array.isArray(body.providers)).toBe(true);
      }
    });
  });

  test.describe('GET /api/health/redis @p1', () => {
    test('[P1] should return Redis cache health status', async ({ request }) => {
      const response = await request.get(`${baseUrl}/api/health/redis`);

      expect([200, 401]).toContain(response.status());
      if (response.status() === 200) {
        const body = await response.json();
        expect(body.status).toBeDefined();
      }
    });
  });
});