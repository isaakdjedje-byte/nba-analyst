/**
 * Policy Global Status API Tests
 * 
 * Coverage: Tests for /api/v1/policy/global-status endpoint
 * Priority: P0 - Critical global policy status monitoring
 * 
 * Generated by: testarch-automate workflow
 */

import { test, expect } from '@playwright/test';
import { faker } from '@faker-js/faker';

test.describe('Policy Global Status API', () => {
  const BASE_URL = '/api/v1/policy/global-status';

  test.describe('GET Global Policy Status', () => {
    test('[P0] should return current global policy status', async ({ request }) => {
      // When: Requesting global policy status
      const response = await request.get(BASE_URL);

      // Then: Should return current status
      expect(response.status()).toBe(200);
      
      const body = await response.json();
      expect(body).toHaveProperty('status');
      expect(body).toHaveProperty('last_updated');
      expect(body).toHaveProperty('policies');
    });

    test('[P0] should require authentication', async ({ request }) => {
      // Given: No authentication token

      // When: Requesting status without auth
      const response = await request.get(BASE_URL);

      // Then: Should return 401 Unauthorized
      expect([401, 403]).toContain(response.status());
    });

    test('[P1] should return status for all policy types', async ({ request }) => {
      // Given: Authenticated request
      const response = await request.get(BASE_URL, {
        headers: {
          'Authorization': `Bearer valid-token`,
        },
      });

      // Then: Should include all policy types
      if (response.status() === 200) {
        const body = await response.json();
        expect(body.policies).toBeDefined();
        
        // Check for expected policy types
        const policyTypes = Object.keys(body.policies);
        expect(policyTypes).toContain('hard_stop');
        expect(policyTypes).toContain('drift');
        expect(policyTypes).toContain('edge');
        expect(policyTypes).toContain('confidence');
      }
    });

    test('[P1] should include active policy configuration', async ({ request }) => {
      // When: Requesting status
      const response = await request.get(BASE_URL, {
        headers: {
          'Authorization': `Bearer valid-token`,
        },
      });

      // Then: Should include active configuration
      if (response.status() === 200) {
        const body = await response.json();
        expect(body).toHaveProperty('active_config');
        expect(body.active_config).toHaveProperty('version');
      }
    });

    test('[P2] should include historical status changes', async ({ request }) => {
      // Given: Request for historical data
      const response = await request.get(`${BASE_URL}?include_history=true`, {
        headers: {
          'Authorization': `Bearer valid-token`,
        },
      });

      // Then: Should include history if requested
      expect([200, 400]).toContain(response.status());
      
      if (response.status() === 200) {
        const body = await response.json();
        expect(body).toHaveProperty('history');
      }
    });
  });

  test.describe('Global Policy Control', () => {
    test('[P0] should allow enabling global policy enforcement', async ({ request }) => {
      // Given: Admin authentication
      // When: Enabling global policy enforcement
      const response = await request.post(`${BASE_URL}/enable`, {
        headers: {
          'Authorization': `Bearer admin-token`,
          'Content-Type': 'application/json',
        },
        data: {
          enabled: true,
          reason: 'Enable for production',
        },
      });

      // Then: Should process the request
      expect([200, 403]).toContain(response.status());
      
      if (response.status() === 200) {
        const body = await response.json();
        expect(body).toHaveProperty('success');
        expect(body.enabled).toBe(true);
      }
    });

    test('[P0] should allow disabling global policy enforcement', async ({ request }) => {
      // Given: Admin authentication
      // When: Disabling global policy enforcement
      const response = await request.post(`${BASE_URL}/disable`, {
        headers: {
          'Authorization': `Bearer admin-token`,
          'Content-Type': 'application/json',
        },
        data: {
          enabled: false,
          reason: 'Maintenance mode',
        },
      });

      // Then: Should process the request
      expect([200, 403]).toContain(response.status());
    });

    test('[P1] should require admin privileges for control actions', async ({ request }) => {
      // Given: Non-admin authentication
      // When: Attempting to control global status
      const response = await request.post(`${BASE_URL}/enable`, {
        headers: {
          'Authorization': `Bearer user-token`, // Non-admin
          'Content-Type': 'application/json',
        },
        data: { enabled: true },
      });

      // Then: Should return 403 Forbidden
      expect(response.status()).toBe(403);
    });

    test('[P2] should validate reason for policy changes', async ({ request }) => {
      // Given: Admin auth but no reason provided
      const response = await request.post(`${BASE_URL}/enable`, {
        headers: {
          'Authorization': `Bearer admin-token`,
          'Content-Type': 'application/json',
        },
        data: {
          enabled: true,
          // No reason provided
        },
      });

      // Then: Should return 400 Bad Request
      expect([400, 422]).toContain(response.status());
    });
  });

  test.describe('Policy Status Filtering', () => {
    test('[P1] should filter status by policy type', async ({ request }) => {
      // Given: Filter parameter for specific policy type
      const response = await request.get(`${BASE_URL}?policy_type=hard_stop`, {
        headers: {
          'Authorization': `Bearer valid-token`,
        },
      });

      // Then: Should return filtered status
      expect([200, 400]).toContain(response.status());
      
      if (response.status() === 200) {
        const body = await response.json();
        expect(body).toHaveProperty('policy_type');
      }
    });

    test('[P2] should support date range filtering', async ({ request }) => {
      // Given: Date range parameters
      const since = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString(); // 24 hours ago
      
      const response = await request.get(`${BASE_URL}?since=${since}`, {
        headers: {
          'Authorization': `Bearer valid-token`,
        },
      });

      // Then: Should return filtered results
      expect([200, 400]).toContain(response.status());
    });
  });
});
