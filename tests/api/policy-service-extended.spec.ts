/**
 * PolicyService API Integration Tests
 * Extended coverage for policy evaluation endpoints
 * 
 * Generated by BMAD testarch-automate workflow
 * Priority: P1 (High) - PolicyService API coverage expansion
 */

import { test, expect } from '@playwright/test';

test.describe('Policy Service API - Extended Coverage @api @policy @p1', () => {
  const BASE_URL = '/api/policy/evaluate';

  test.describe('Request Validation', () => {
    test('[P0] should reject request without modelOutputs', async ({ request }) => {
      const response = await request.post(BASE_URL, {
        data: {},
      });
      
      // Validation error expected
      expect([400, 422]).toContain(response.status());
    });

    test('[P0] should reject invalid confidence value (negative)', async ({ request }) => {
      const response = await request.post(BASE_URL, {
        data: {
          modelOutputs: {
            confidence: -0.5,
            edge: 0.05,
            drift: 0.05,
          },
        },
      });
      
      // Should handle invalid input gracefully
      expect([400, 422, 500]).toContain(response.status());
    });

    test('[P0] should reject invalid confidence value (>1)', async ({ request }) => {
      const response = await request.post(BASE_URL, {
        data: {
          modelOutputs: {
            confidence: 1.5,
            edge: 0.05,
            drift: 0.05,
          },
        },
      });
      
      expect([400, 422, 500]).toContain(response.status());
    });

    test('[P1] should handle missing optional edge field', async ({ request }) => {
      const response = await request.post(BASE_URL, {
        data: {
          modelOutputs: {
            confidence: 0.75,
            // edge missing
            drift: 0.05,
          },
        },
      });
      
      // Should handle gracefully (edge defaults or is optional)
      expect([200, 400, 422]).toContain(response.status());
    });

    test('[P1] should handle missing optional drift field', async ({ request }) => {
      const response = await request.post(BASE_URL, {
        data: {
          modelOutputs: {
            confidence: 0.75,
            edge: 0.05,
            // drift missing
          },
        },
      });
      
      expect([200, 400, 422]).toContain(response.status());
    });

    test('[P2] should handle all optional fields missing', async ({ request }) => {
      const response = await request.post(BASE_URL, {
        data: {
          modelOutputs: {
            confidence: 0.75,
          },
        },
      });
      
      // Minimal valid request
      expect(response.status()).toBe(200);
    });
  });

  test.describe('v1 Policy Endpoint', () => {
    test('[P0] should evaluate via v1 endpoint', async ({ request }) => {
      const response = await request.post('/api/v1/policy/evaluate', {
        data: {
          modelOutputs: {
            confidence: 0.80,
            edge: 0.10,
            drift: 0.02,
          },
        },
      });
      
      // v1 endpoint should work similarly
      expect([200, 404]).toContain(response.status());
    });

    test('[P1] should maintain backward compatibility', async ({ request }) => {
      // Test that both endpoints return similar structure
      const v1Response = await request.post('/api/v1/policy/evaluate', {
        data: {
          modelOutputs: {
            confidence: 0.75,
            edge: 0.05,
            drift: 0.05,
          },
        },
      });
      
      const v2Response = await request.post(BASE_URL, {
        data: {
          modelOutputs: {
            confidence: 0.75,
            edge: 0.05,
            drift: 0.05,
          },
        },
      });

      // Both should either work or both fail consistently
      if (v1Response.status() === 200 && v2Response.status() === 200) {
        const v1Body = await v1Response.json();
        const v2Body = await v2Response.json();
        
        // Both should have similar response structure
        expect(v1Body).toHaveProperty('status');
        expect(v2Body).toHaveProperty('status');
      }
    });
  });

  test.describe('Error Handling', () => {
    test('[P1] should return proper error format', async ({ request }) => {
      const response = await request.post(BASE_URL, {
        data: {
          modelOutputs: {
            confidence: 'invalid' as any,
          },
        },
      });
      
      const body = await response.json();
      
      // Should have error structure
      expect(body).toHaveProperty('error');
    });

    test('[P2] should handle malformed JSON', async ({ request }) => {
      // Send malformed request
      const response = await request.post(BASE_URL, {
        data: 'not valid json' as any,
      });
      
      // Should handle gracefully
      expect([400, 415, 500]).toContain(response.status());
    });
  });

  test.describe('Response Format', () => {
    test('[P0] should return decision status', async ({ request }) => {
      const response = await request.post(BASE_URL, {
        data: {
          modelOutputs: {
            confidence: 0.85,
            edge: 0.10,
            drift: 0.02,
          },
        },
      });
      
      if (response.status() === 200) {
        const body = await response.json();
        expect(body).toHaveProperty('status');
        expect(['Pick', 'No-Bet', 'Hard-Stop']).toContain(body.status);
      }
    });

    test('[P0] should include gate outcomes', async ({ request }) => {
      const response = await request.post(BASE_URL, {
        data: {
          modelOutputs: {
            confidence: 0.70,
            edge: 0.08,
            drift: 0.05,
          },
        },
      });
      
      if (response.status() === 200) {
        const body = await response.json();
        expect(body).toHaveProperty('gates');
        expect(body.gates).toHaveProperty('confidenceGate');
        expect(body.gates).toHaveProperty('edgeGate');
        expect(body.gates).toHaveProperty('driftGate');
      }
    });

    test('[P1] should include rationale', async ({ request }) => {
      const response = await request.post(BASE_URL, {
        data: {
          modelOutputs: {
            confidence: 0.60,
            edge: 0.03,
            drift: 0.20,
          },
        },
      });
      
      if (response.status() === 200) {
        const body = await response.json();
        expect(body).toHaveProperty('rationale');
        expect(typeof body.rationale).toBe('string');
      }
    });

    test('[P1] should include timestamp', async ({ request }) => {
      const response = await request.post(BASE_URL, {
        data: {
          modelOutputs: {
            confidence: 0.75,
            edge: 0.05,
            drift: 0.05,
          },
        },
      });
      
      if (response.status() === 200) {
        const body = await response.json();
        expect(body).toHaveProperty('evaluatedAt');
      }
    });
  });

  test.describe('Hard Stop Scenarios', () => {
    test('[P0] should detect hard stop condition - high loss', async ({ request }) => {
      const response = await request.post(BASE_URL, {
        data: {
          modelOutputs: {
            confidence: 0.90,
            edge: 0.15,
            drift: 0.01,
          },
          context: {
            dailyLoss: 1500, // Exceeds daily limit
            consecutiveLosses: 3,
            currentBankroll: 1000,
          },
        },
      });
      
      if (response.status() === 200) {
        const body = await response.json();
        // If context is supported, should return Hard-Stop
        if (body.status) {
          expect(['Pick', 'No-Bet', 'Hard-Stop']).toContain(body.status);
        }
      }
    });

    test('[P0] should detect hard stop condition - consecutive losses', async ({ request }) => {
      const response = await request.post(BASE_URL, {
        data: {
          modelOutputs: {
            confidence: 0.90,
            edge: 0.15,
            drift: 0.01,
          },
          context: {
            dailyLoss: 500,
            consecutiveLosses: 6, // Exceeds limit
            currentBankroll: 1000,
          },
        },
      });
      
      // Should handle or respect hard stop
      expect([200, 400]).toContain(response.status());
    });
  });

  test.describe('Performance', () => {
    test('[P2] should respond within acceptable time', async ({ request }) => {
      const startTime = Date.now();
      
      const response = await request.post(BASE_URL, {
        data: {
          modelOutputs: {
            confidence: 0.75,
            edge: 0.05,
            drift: 0.05,
          },
        },
      });
      
      const duration = Date.now() - startTime;
      
      if (response.status() === 200) {
        expect(duration).toBeLessThan(2000); // Should respond within 2 seconds
      }
    });
  });
});
