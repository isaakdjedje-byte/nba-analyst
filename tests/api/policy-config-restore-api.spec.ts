/**
 * Policy Config Restore API Tests
 * 
 * Coverage: Tests for /api/v1/policy/config/restore/{versionId} endpoint
 * Priority: P0 - Critical configuration restoration functionality
 * 
 * Generated by: testarch-automate workflow
 */

import { test, expect } from '@playwright/test';
import { faker } from '@faker-js/faker';

test.describe('Policy Config Restore API', () => {
  const BASE_URL = '/api/v1/policy/config/restore';

  // Helper to generate a valid version ID
  const generateVersionId = () => `v-${faker.string.uuid()}`;

  test.describe('Restore Policy Configuration', () => {
    test('[P0] should restore a valid policy configuration version', async ({ request }) => {
      // Given: A valid policy version ID exists
      const versionId = generateVersionId();
      
      // When: Requesting to restore a specific policy version
      const response = await request.post(`${BASE_URL}/${versionId}`, {
        headers: {
          'Content-Type': 'application/json',
        },
      });

      // Then: Should return success status
      // Note: This may return 404 if version doesn't exist - adjust assertion accordingly
      expect([200, 404]).toContain(response.status());
      
      if (response.status() === 200) {
        const body = await response.json();
        expect(body).toHaveProperty('success');
        expect(body).toHaveProperty('restored_version');
        expect(body).toHaveProperty('previous_version');
      }
    });

    test('[P0] should require authentication to restore configuration', async ({ request }) => {
      // Given: No authentication token provided
      const versionId = generateVersionId();

      // When: Attempting to restore without auth
      const response = await request.post(`${BASE_URL}/${versionId}`, {
        headers: {
          'Content-Type': 'application/json',
          // No Authorization header
        },
      });

      // Then: Should return 401 Unauthorized
      expect(response.status()).toBe(401);
    });

    test('[P1] should handle invalid version ID format', async ({ request }) => {
      // Given: An invalid version ID format
      const invalidVersionId = 'invalid-format-!@#';

      // When: Attempting to restore with invalid ID
      const response = await request.post(`${BASE_URL}/${invalidVersionId}`);

      // Then: Should return 400 Bad Request
      expect([400, 404]).toContain(response.status());
    });

    test('[P1] should restore with admin privileges', async ({ request }) => {
      // Given: Admin authentication
      const versionId = generateVersionId();

      // When: Admin user requests restore
      const response = await request.post(`${BASE_URL}/${versionId}`, {
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer admin-token`, // Admin token
        },
      });

      // Then: Should process the request
      expect([200, 404]).toContain(response.status());
    });

    test('[P2] should validate version exists before restore', async ({ request }) => {
      // Given: A non-existent version ID
      const nonExistentVersionId = `v-${faker.string.uuid()}`;

      // When: Attempting to restore non-existent version
      const response = await request.post(`${BASE_URL}/${nonExistentVersionId}`, {
        headers: {
          'Authorization': `Bearer admin-token`,
        },
      });

      // Then: Should return 404 Not Found
      expect(response.status()).toBe(404);
      
      const body = await response.json();
      expect(body).toHaveProperty('error');
      expect(body.error).toContain('version');
    });

    test('[P2] should create backup before restore', async ({ request }) => {
      // Given: A valid version to restore
      const versionId = generateVersionId();

      // When: Restoring creates automatic backup
      const response = await request.post(`${BASE_URL}/${versionId}`, {
        headers: {
          'Authorization': `Bearer admin-token`,
        },
      });

      // Then: Response should indicate backup was created (if successful)
      if (response.status() === 200) {
        const body = await response.json();
        expect(body).toHaveProperty('backup_created');
      }
    });
  });

  test.describe('GET Restore History', () => {
    test('[P1] should retrieve restore history', async ({ request }) => {
      // When: Requesting restore history
      const response = await request.get(`${BASE_URL}/history`);

      // Then: Should return history of restores
      expect([200, 401]).toContain(response.status());
      
      if (response.status() === 200) {
        const body = await response.json();
        expect(body).toHaveProperty('restores');
        expect(Array.isArray(body.restores)).toBe(true);
      }
    });

    test('[P2] should filter restore history by date range', async ({ request }) => {
      // Given: Date range parameters
      const startDate = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString(); // 7 days ago
      const endDate = new Date().toISOString();

      // When: Filtering history by date
      const response = await request.get(`${BASE_URL}/history?start=${startDate}&end=${endDate}`);

      // Then: Should return filtered results
      expect([200, 400, 401]).toContain(response.status());
    });
  });
});
