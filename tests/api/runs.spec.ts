/**
 * Runs API Tests
 * Tests for Runs management endpoints
 *
 * Generated by BMAD testarch-automate workflow
 * Priority: P1 (High)
 */

import { test, expect } from '../support/merged-fixtures';
import { createRun, createFailedRun, createRunningRun } from '../support/factories';

test.describe('Runs API - P1 @p1 @api @runs', () => {
  const createdRunIds: string[] = [];

  test.afterEach(async ({ request }) => {
    // Cleanup: Delete all runs created during test
    for (const runId of createdRunIds) {
      await request.delete(`/api/v1/runs/${runId}`).catch(() => {});
    }
    createdRunIds.length = 0;
  });

  test('[P0] should create a new run via API', async ({ api }) => {
    // Given a valid run data
    const run = createRun({ status: 'pending' });

    // When creating run via API
    const response = await api.post('/api/v1/runs', { data: run });

    // Then response should be successful
    expect(response.status()).toBe(201);

    const created = await response.json();
    expect(created.id).toBeTruthy();
    expect(created.status).toBe('pending');
    expect(created.traceId).toBe(run.traceId);
    
    // Track for cleanup
    createdRunIds.push(created.id);
  });

  test('[P0] should retrieve all runs via API', async ({ api }) => {
    // Given runs exist in the system
    const run1 = createRun();
    const run2 = createRun();
    const response1 = await api.post('/api/v1/runs', { data: run1 });
    const response2 = await api.post('/api/v1/runs', { data: run2 });
    
    const created1 = await response1.json();
    const created2 = await response2.json();
    createdRunIds.push(created1.id, created2.id);

    // When retrieving runs via API
    const response = await api.get('/api/v1/runs');

    // Then response should contain runs
    expect(response.status()).toBe(200);
    const body = await response.json();
    expect(body.runs).toBeDefined();
    expect(Array.isArray(body.runs)).toBe(true);
    expect(body.runs.length).toBeGreaterThanOrEqual(2);
  });

  test('[P1] should create run with failed status', async ({ api }) => {
    // Given a failed run
    const failedRun = createFailedRun();

    // When creating via API
    const response = await api.post('/api/v1/runs', { data: failedRun });

    // Then should be created with failed status
    expect(response.status()).toBe(201);
    const created = await response.json();
    expect(created.status).toBe('failed');
    expect(created.errorsCount).toBeGreaterThan(0);
    expect(created.completedAt).toBeUndefined();
    
    // Track for cleanup
    createdRunIds.push(created.id);
  });

  test('[P1] should create run with running status', async ({ api }) => {
    // Given a running run
    const runningRun = createRunningRun();

    // When creating via API
    const response = await api.post('/api/v1/runs', { data: runningRun });

    // Then should be created with running status
    expect(response.status()).toBe(201);
    const created = await response.json();
    expect(created.status).toBe('running');
    expect(created.completedAt).toBeUndefined();
    
    // Track for cleanup
    createdRunIds.push(created.id);
  });

  test('[P1] should persist run data correctly', async ({ api }) => {
    // Given a run with specific data
    const run = createRun({
      decisionsCount: 15,
      errorsCount: 2,
    });

    // When creating via API
    const createResponse = await api.post('/api/v1/runs', { data: run });
    const created = await createResponse.json();
    
    // Track for cleanup
    createdRunIds.push(created.id);

    // And retrieving via API
    const getResponse = await api.get('/api/v1/runs');
    const { runs } = await getResponse.json();

    // Then data should be persisted correctly
    const foundRun = runs.find((r: { id: string }) => r.id === created.id);
    expect(foundRun).toBeDefined();
    expect(foundRun.decisionsCount).toBe(15);
    expect(foundRun.errorsCount).toBe(2);
  });

  test('[P2] should handle empty runs list', async ({ api }) => {
    // When retrieving runs
    const response = await api.get('/api/v1/runs');

    // Then should return empty array if no runs
    expect(response.status()).toBe(200);
    const body = await response.json();
    expect(body.runs).toBeDefined();
    expect(Array.isArray(body.runs)).toBe(true);
  });
});
