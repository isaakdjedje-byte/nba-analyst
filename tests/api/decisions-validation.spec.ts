/**
 * Decisions API Validation Tests
 * Tests for decision endpoint validation and error handling
 *
 * Generated by BMAD testarch-automate workflow
 * Priority: P1 (High)
 */

import { test, expect } from '../support/merged-fixtures';
import { createDecision, createMatch } from '../support/factories';

test.describe('Decisions API Validation - P1 @p1 @api @decisions @validation', () => {
  const createdDecisionIds: string[] = [];

  test.afterEach(async ({ request }) => {
    // Cleanup: Delete all decisions created during test
    for (const decisionId of createdDecisionIds) {
      await request.delete(`/api/v1/decisions/${decisionId}`).catch(() => {});
    }
    createdDecisionIds.length = 0;
  });

  test('[P0] should reject decision with missing matchId', async ({ api }) => {
    // Given decision without matchId
    const decision = {
      status: 'Pick',
      confidence: 0.85,
      rationale: 'Strong favorite',
    };

    // When attempting to create
    const response = await api.post('/api/v1/decisions', { data: decision });

    // Then should return bad request
    expect(response.status()).toBe(400);
    const body = await response.json();
    expect(body.error).toBeDefined();
  });

  test('[P0] should reject decision with invalid status', async ({ api }) => {
    // Given a match
    const match = createMatch();

    // And decision with invalid status
    const decision = {
      matchId: match.id,
      status: 'InvalidStatus',
      confidence: 0.85,
    };

    // When attempting to create
    const response = await api.post('/api/v1/decisions', { data: decision });

    // Then should return bad request
    expect(response.status()).toBe(400);
    const body = await response.json();
    expect(body.error).toBeDefined();
  });

  test('[P1] should reject decision with negative confidence', async ({ api }) => {
    // Given a match
    const match = createMatch();

    // And decision with negative confidence
    const decision = createDecision({
      matchId: match.id,
      confidence: -0.5,
    });

    // When attempting to create
    const response = await api.post('/api/v1/decisions', { data: decision });

    // Then should return bad request
    expect(response.status()).toBe(400);
    const body = await response.json();
    expect(body.error).toBeDefined();
  });

  test('[P1] should reject decision with confidence over 1', async ({ api }) => {
    // Given a match
    const match = createMatch();

    // And decision with confidence > 1
    const decision = createDecision({
      matchId: match.id,
      confidence: 1.5,
    });

    // When attempting to create
    const response = await api.post('/api/v1/decisions', { data: decision });

    // Then should return bad request
    expect(response.status()).toBe(400);
    const body = await response.json();
    expect(body.error).toBeDefined();
  });

  test('[P1] should handle empty decisions list', async ({ api }) => {
    // When retrieving decisions
    const response = await api.get('/api/v1/decisions');

    // Then should return empty array
    expect(response.status()).toBe(200);
    const body = await response.json();
    expect(body.decisions).toBeDefined();
    expect(Array.isArray(body.decisions)).toBe(true);
  });

  test('[P2] should create decision with minimal required fields', async ({ api }) => {
    // Given minimal decision data
    const match = createMatch();
    const minimalDecision = {
      matchId: match.id,
      status: 'Pick',
    };

    // When creating via API
    const response = await api.post('/api/v1/decisions', { data: minimalDecision });

    // Then should be created with defaults
    expect(response.status()).toBe(201);
    const created = await response.json();
    expect(created.id).toBeDefined();
    expect(created.matchId).toBe(match.id);

    // Track for cleanup
    createdDecisionIds.push(created.id);
  });

  test('[P2] should persist decision traceId', async ({ api }) => {
    // Given a decision with traceId
    const match = createMatch();
    const decision = createDecision({
      matchId: match.id,
      traceId: 'test-trace-123',
    });

    // When creating via API
    const createResponse = await api.post('/api/v1/decisions', { data: decision });
    const created = await createResponse.json();

    // Track for cleanup
    createdDecisionIds.push(created.id);

    // And retrieving
    const getResponse = await api.get('/api/v1/decisions');
    const { decisions } = await getResponse.json();

    // Then traceId should be persisted
    const found = decisions.find((d: { id: string }) => d.id === created.id);
    expect(found).toBeDefined();
    expect(found.traceId).toBe('test-trace-123');
  });
});
