/**
 * Users API CRUD Tests
 * Tests for user management endpoints
 *
 * Generated by BMAD testarch-automate workflow
 * Priority: P1 (High)
 * Test IDs: 1.2-USER-001 through 1.2-USER-010
 */

import { test, expect } from '@playwright/test';
import { createUser, createAdminUser } from '../support/factories';

test.describe('Users API CRUD - P1 @p1 @api @users @crud', () => {
  const baseUrl = process.env.BASE_URL || 'http://localhost:3000';
  const createdUserIds: string[] = [];

  test.afterEach(async ({ request }) => {
    // Cleanup: Delete all users created during test
    for (const userId of createdUserIds) {
      await request.delete(`${baseUrl}/api/users?id=${userId}`).catch(() => {});
    }
    createdUserIds.length = 0;
  });

  test('[P0] [1.2-USER-001] should create a new user via API', async ({ request }) => {
    // Given valid user data using factory (no Date.now())
    const userData = createUser({
      email: 'test-create@example.com',
      name: 'Test User',
      role: 'user',
    });

    // When creating via API
    const response = await request.post(`${baseUrl}/api/users`, {
      data: userData,
    });

    // Then user should be created
    expect(response.status()).toBe(201);
    const created = await response.json();
    expect(created.id).toBeDefined();
    expect(created.email).toBe(userData.email);
    expect(created.name).toBe(userData.name);
    expect(created.role).toBe('user');
    expect(created.isActive).toBe(true);
    expect(created.createdAt).toBeDefined();

    // Track for cleanup
    createdUserIds.push(created.id);
  });

  test('[P0] [1.2-USER-002] should reject user creation without email', async ({ request }) => {
    // Given user data without email
    const userData = {
      name: 'Test User',
      role: 'user',
    };

    // When attempting to create
    const response = await request.post(`${baseUrl}/api/users`, {
      data: userData,
    });

    // Then should return bad request
    expect(response.status()).toBe(400);
    const body = await response.json();
    expect(body.error).toContain('Email is required');
  });

  test('[P0] [1.2-USER-003] should reject user creation without name', async ({ request }) => {
    // Given user data without name using factory
    const userData = createUser({
      email: 'no-name@example.com',
      name: '',
      role: 'user',
    });

    // When attempting to create
    const response = await request.post(`${baseUrl}/api/users`, {
      data: userData,
    });

    // Then should return bad request
    expect(response.status()).toBe(400);
    const body = await response.json();
    expect(body.error).toContain('Name is required');
  });

  test('[P1] [1.2-USER-004] should reject duplicate email addresses', async ({ request }) => {
    // Given an existing user using factory
    const userData = createUser({
      email: 'duplicate@example.com',
      name: 'First User',
    });

    const firstResponse = await request.post(`${baseUrl}/api/users`, {
      data: userData,
    });
    expect(firstResponse.status()).toBe(201);
    const firstUser = await firstResponse.json();
    createdUserIds.push(firstUser.id);

    // When attempting to create another user with same email
    const duplicateData = {
      ...userData,
      name: 'Second User',
    };
    const secondResponse = await request.post(`${baseUrl}/api/users`, {
      data: duplicateData,
    });

    // Then should return conflict
    expect(secondResponse.status()).toBe(409);
    const body = await secondResponse.json();
    expect(body.error).toContain('Email already exists');
  });

  test('[P1] [1.2-USER-005] should retrieve all users via GET', async ({ request }) => {
    // Given multiple users exist using factories
    const user1 = createUser({ email: 'user1@example.com' });
    const user2 = createAdminUser({ email: 'admin1@example.com' });

    const resp1 = await request.post(`${baseUrl}/api/users`, { data: user1 });
    const resp2 = await request.post(`${baseUrl}/api/users`, { data: user2 });

    expect(resp1.status()).toBe(201);
    expect(resp2.status()).toBe(201);

    const created1 = await resp1.json();
    const created2 = await resp2.json();
    createdUserIds.push(created1.id, created2.id);

    // When retrieving all users
    const response = await request.get(`${baseUrl}/api/users`);

    // Then should return users list
    expect(response.status()).toBe(200);
    const body = await response.json();
    expect(body.users).toBeDefined();
    expect(Array.isArray(body.users)).toBe(true);
    expect(body.users.length).toBeGreaterThanOrEqual(2);

    // And should include our created users
    const emails = body.users.map((u: { email: string }) => u.email);
    expect(emails).toContain(user1.email);
    expect(emails).toContain(user2.email);
  });

  test('[P1] [1.2-USER-006] should delete user by ID', async ({ request }) => {
    // Given an existing user using factory
    const userData = createUser({ email: 'delete-me@example.com' });
    const createResponse = await request.post(`${baseUrl}/api/users`, { data: userData });
    expect(createResponse.status()).toBe(201);
    const created = await createResponse.json();

    // When deleting the user
    const deleteResponse = await request.delete(`${baseUrl}/api/users?id=${created.id}`);

    // Then should return success
    expect(deleteResponse.status()).toBe(200);
    const body = await deleteResponse.json();
    expect(body.success).toBe(true);

    // And user should no longer exist
    const getResponse = await request.get(`${baseUrl}/api/users`);
    const { users } = await getResponse.json();
    const found = users.find((u: { id: string }) => u.id === created.id);
    expect(found).toBeUndefined();
  });

  test('[P1] [1.2-USER-007] should return 404 when deleting non-existent user', async ({ request }) => {
    // When attempting to delete non-existent user
    const response = await request.delete(`${baseUrl}/api/users?id=non-existent-id`);

    // Then should return not found
    expect(response.status()).toBe(404);
    const body = await response.json();
    expect(body.error).toContain('User not found');
  });

  test('[P2] [1.2-USER-008] should assign default role when not specified', async ({ request }) => {
    // Given user data without role using factory
    const userData = createUser({
      email: 'default-role@example.com',
      name: 'Test User',
    });
    // Override to remove role
    const { role, ...userWithoutRole } = userData;

    // When creating via API
    const response = await request.post(`${baseUrl}/api/users`, {
      data: userWithoutRole,
    });

    // Then should default to 'user' role
    expect(response.status()).toBe(201);
    const created = await response.json();
    expect(created.role).toBe('user');

    createdUserIds.push(created.id);
  });

  test('[P2] [1.2-USER-009] should handle empty users list', async ({ request }) => {
    // When retrieving users (before creating any)
    const response = await request.get(`${baseUrl}/api/users`);

    // Then should return empty array
    expect(response.status()).toBe(200);
    const body = await response.json();
    expect(body.users).toBeDefined();
    expect(Array.isArray(body.users)).toBe(true);
  });

  test('[P2] [1.2-USER-010] should preserve createdAt timestamp', async ({ request }) => {
    // Given user creation request using factory
    const userData = createUser({ email: 'timestamp@example.com' });
    const beforeCreate = Date.now();

    // When creating user
    const response = await request.post(`${baseUrl}/api/users`, { data: userData });
    const afterCreate = Date.now();

    // Then createdAt should be valid timestamp
    expect(response.status()).toBe(201);
    const created = await response.json();
    const createdAt = new Date(created.createdAt).getTime();
    expect(createdAt).toBeGreaterThanOrEqual(beforeCreate);
    expect(createdAt).toBeLessThanOrEqual(afterCreate);

    createdUserIds.push(created.id);
  });
});
