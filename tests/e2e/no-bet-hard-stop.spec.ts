/**
 * No-Bet and Hard-Stop E2E Tests
 * Tests for policy enforcement and guardrails
 *
 * Generated by BMAD testarch-framework workflow
 */

import { test, expect } from '../support/merged-fixtures';
import { createNoBetDecision, createHardStopDecision, createMatch } from '../support/factories';

test.describe('No-Bet Flow', () => {
  test.beforeEach(async ({ page }) => {
    const responsePromise = page.waitForResponse(resp => resp.url().includes('/api/') || resp.status() === 200);
    await page.goto('/dashboard/no-bet');
    await responsePromise;
  });

  test('[P1] [1.2-NB-010] should display no-bet recommendations', async ({ page }) => {
    // Given the user is on the no-bet page
    // Then the no-bet list should be visible
    await expect(page.getByTestId('no-bet-list')).toBeVisible();
  });

  test('[P1] [1.2-NB-011] should show rationale for no-bet', async ({ page, request }) => {
    // Given a no-bet decision exists
    const match = createMatch();
    const decision = createNoBetDecision({ matchId: match.id });

    const baseUrl = process.env.BASE_URL || 'http://localhost:3000';
    const createResponse = await request.post(`${baseUrl}/api/v1/decisions`, {
      data: decision,
      headers: { 'Content-Type': 'application/json' },
    });
    const created = await createResponse.json();

    // When the user visits the no-bet page
    const responsePromise = page.waitForResponse(resp => resp.url().includes('/api/') || resp.status() === 200);
    await page.goto('/dashboard/no-bet');
    await responsePromise;

    // Then the no-bet rationale should be visible
    const rationale = page.getByTestId(`no-bet-rationale-${created.id}`);
    const genericRationale = page.getByTestId('no-bet-card');
    await expect(rationale.or(genericRationale).first()).toBeVisible();

    // Cleanup
    await request.delete(`${baseUrl}/api/v1/decisions/${created.id}`).catch(() => {});
  });

  test('[P1] [1.2-NB-012] should display policy gates that failed', async ({ page, request }) => {
    // Given a no-bet decision exists via API setup
    const match = createMatch();
    const decision = createNoBetDecision({ matchId: match.id });
    
    const baseUrl = process.env.BASE_URL || 'http://localhost:3000';
    const createResponse = await request.post(`${baseUrl}/api/v1/decisions`, {
      data: decision,
      headers: { 'Content-Type': 'application/json' },
    });
    const created = await createResponse.json();
    
    // When the user views a no-bet card
    const responsePromise = page.waitForResponse(resp => resp.url().includes('/api/') || resp.status() === 200);
    await page.goto('/dashboard/no-bet');
    await responsePromise;
    
    const noBetCard = page.getByTestId('no-bet-card').first();
    await expect(noBetCard).toBeVisible();
    await noBetCard.click();

    // Then the failed policy gates should be displayed
    await expect(page.getByTestId('failed-gates')).toBeVisible();
    
    // Cleanup
    await request.delete(`${baseUrl}/api/v1/decisions/${created.id}`).catch(() => {});
  });

  test('[P2] [1.2-NB-013] should allow drilling down for more info', async ({ page, request }) => {
    // Given a no-bet decision exists via API setup
    const match = createMatch();
    const decision = createNoBetDecision({ matchId: match.id });
    
    const baseUrl = process.env.BASE_URL || 'http://localhost:3000';
    const createResponse = await request.post(`${baseUrl}/api/v1/decisions`, {
      data: decision,
      headers: { 'Content-Type': 'application/json' },
    });
    const created = await createResponse.json();
    
    // When the user views a no-bet card and clicks "Learn more"
    const responsePromise = page.waitForResponse(resp => resp.url().includes('/api/') || resp.status() === 200);
    await page.goto('/dashboard/no-bet');
    await responsePromise;
    
    const noBetCard = page.getByTestId('no-bet-card').first();
    await expect(noBetCard).toBeVisible();
    
    await page.getByTestId('learn-more-btn').first().click();

    // Then the detailed explanation should be shown
    await expect(page.getByTestId('detailed-explanation')).toBeVisible();
    
    // Cleanup
    await request.delete(`${baseUrl}/api/v1/decisions/${created.id}`).catch(() => {});
  });
});

test.describe('Hard-Stop Flow', () => {
  test('[P0] [1.2-HS-001] should enforce hard-stop on policy violation', async ({ page, request }) => {
    // Given a decision with hard-stop policy violation
    const match = createMatch();
    const decision = createHardStopDecision({ matchId: match.id });

    const baseUrl = process.env.BASE_URL || 'http://localhost:3000';
    const createResponse = await request.post(`${baseUrl}/api/v1/decisions`, {
      data: decision,
      headers: { 'Content-Type': 'application/json' },
    });
    const created = await createResponse.json();

    // When the user tries to view the pick
    const responsePromise = page.waitForResponse(resp => resp.url().includes('/api/') || resp.status() === 200);
    await page.goto('/dashboard/picks');
    await responsePromise;

    // Then the hard-stop banner or no-bet list should be displayed
    const hardStopBanner = page.getByTestId('hard-stop-banner');
    const noBetList = page.getByTestId('no-bet-list');
    await expect(hardStopBanner.or(noBetList).first()).toBeVisible();

    // Cleanup
    await request.delete(`${baseUrl}/api/v1/decisions/${created.id}`).catch(() => {});
  });

  test('[P0] [1.2-HS-002] should block pick publication on hard-stop', async ({ request }) => {
    // Given a decision with hard-stop
    const decision = createHardStopDecision();

    const baseUrl = process.env.BASE_URL || 'http://localhost:3000';
    const createResponse = await request.post(`${baseUrl}/api/v1/decisions`, {
      data: decision,
      headers: { 'Content-Type': 'application/json' },
    });
    const created = await createResponse.json();

    // When attempting to publish via API
    const response = await request.post(`${baseUrl}/api/v1/decisions/publish`, {
      data: { decisionId: created.id },
      headers: { 'Content-Type': 'application/json' },
    });

    // Then the publication should be blocked
    expect(response.status()).toBe(403);

    // Cleanup
    await request.delete(`${baseUrl}/api/v1/decisions/${created.id}`).catch(() => {});
  });

  test('[P1] [1.2-HS-003] should show audit trail for hard-stop', async ({ page }) => {
    // Given a hard-stop decision exists
    // When the user views the decision logs
    const responsePromise = page.waitForResponse(resp => resp.url().includes('/api/') || resp.status() === 200);
    await page.goto('/dashboard/logs');
    await responsePromise;

    // Then the hard-stop event or log entries should be visible
    const auditLog = page.getByTestId('audit-log-entry');
    const logTrace = page.getByTestId('log-trace-id');
    await expect(auditLog.or(logTrace).first()).toBeVisible();
  });
});

test.describe('Policy Engine Integration', () => {
  test('[P1] [1.2-POL-001] should evaluate policy via API', async ({ request }) => {
    // When evaluating a decision against policy
    const baseUrl = process.env.BASE_URL || 'http://localhost:3000';
    const response = await request.post(`${baseUrl}/api/policy/evaluate`, {
      data: {
        modelOutputs: {
          winner: 'Team A',
          confidence: 0.85,
          edge: 0.03,
        },
      },
      headers: { 'Content-Type': 'application/json' },
    });

    // Then the policy result should be returned
    expect(response.ok()).toBeTruthy();
    const body = await response.json();
    expect(body.status).toBeDefined();
    expect(body.gates).toBeDefined();
  });
});
