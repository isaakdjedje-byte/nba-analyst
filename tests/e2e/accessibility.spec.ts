/**
 * Accessibility Tests
 * WCAG 2.1 AA compliance validation using axe-core
 *
 * Generated by BMAD testarch-automate workflow
 * Priority: P1 (High) - Accessibility is legally required (RGPD + accessibility laws)
 *
 * Tags:
 * - @p1: High priority (accessibility compliance required)
 * - @a11y: Accessibility tests
 * - @wcag: WCAG compliance tests
 * - @regression: Run in regression suite
 */

import { test, expect } from '../support/merged-fixtures';
import AxeBuilder from '@axe-core/playwright';

/**
 * Accessibility test configuration
 * WCAG 2.1 Level AA standards
 */
const axeConfig = {
  rules: {
    // Critical rules that must pass
    'color-contrast': { enabled: true },
    'keyboard-accessibility': { enabled: true },
    'focus-order': { enabled: true },
    'aria-required': { enabled: true },
    'aria-roles': { enabled: true },
    'aria-prohibited-attr': { enabled: true },
    'label': { enabled: true },
    'image-alt': { enabled: true },
    'heading-order': { enabled: true },
    'landmark-one-main': { enabled: true },
    'region': { enabled: true },
    'skip-link': { enabled: true },
    'tabindex': { enabled: true },
  },
};

/**
 * Helper function to run axe accessibility check
 */
async function runAccessibilityCheck(page: any, options: any = {}) {
  const builder = new AxeBuilder({ page })
    .withTags(['wcag2a', 'wcag2aa', 'wcag21aa'])
    .options({
      ...axeConfig,
      ...options,
    });

  const results = await builder.analyze();
  return results;
}

test.describe('Accessibility @p1 @a11y @wcag @regression', () => {
  test.describe('Login Page Accessibility', () => {
    test('@p0 @a11y login page should have no critical accessibility violations', async ({ page }) => {
      // Given login page
      await page.goto('/login');

      // When running accessibility scan
      const results = await runAccessibilityCheck(page);

      // Then there should be no critical or serious violations
      const criticalAndSerious = results.violations.filter(
        (v: { impact: string }) => v.impact === 'critical' || v.impact === 'serious'
      );

      expect(
        criticalAndSerious,
        `Found ${criticalAndSerious.length} critical/serious accessibility violations: ${
          criticalAndSerious.map((v: { description: string }) => v.description).join(', ')
        }`
      ).toHaveLength(0);
    });

    test('@p1 @a11y login form should have proper labels', async ({ page }) => {
      // Given login page
      await page.goto('/login');

      // Then form inputs should have proper labels
      const emailInput = page.locator('input[type="email"], input[name="email"]');
      const passwordInput = page.locator('input[type="password"], input[name="password"]');

      // Check for aria-label or associated label
      for (const input of [emailInput, passwordInput]) {
        const ariaLabel = await input.getAttribute('aria-label');
        const ariaLabelledBy = await input.getAttribute('aria-labelledby');
        const hasLabel = await input.locator('xpath=preceding::label[1]').count() > 0;

        expect(
          ariaLabel || ariaLabelledBy || hasLabel,
          'Input field must have a label'
        ).toBeTruthy();
      }
    });

    test('@p1 @a11y login page should have proper heading structure', async ({ page }) => {
      // Given login page
      await page.goto('/login');

      // Then there should be exactly one H1
      const h1Count = await page.locator('h1').count();
      expect(h1Count).toBe(1);

      // Headings should be in order
      const results = await runAccessibilityCheck(page);
      const headingOrderViolation = results.violations.find(
        (v: { id: string }) => v.id === 'heading-order'
      );
      expect(headingOrderViolation).toBeUndefined();
    });
  });

  test.describe('Dashboard Accessibility', () => {
    test('@p1 @a11y dashboard should have proper landmark regions', async ({ page }) => {
      // Given authenticated user on dashboard
      await page.goto('/login');
      await page.fill('[data-testid="email"]', 'test@example.com');
      await page.fill('[data-testid="password"]', 'testpassword123');
      await page.click('[data-testid="login-button"]');
      await page.waitForURL(/.*dashboard/);

      // Then page should have main landmark
      const main = page.locator('main, [role="main"]');
      await expect(main).toBeVisible();

      // Should have navigation landmark if navigation exists
      const nav = page.locator('nav, [role="navigation"]');
      const navCount = await nav.count();
      if (navCount > 0) {
        await expect(nav.first()).toBeVisible();
      }

      // Run accessibility scan
      const results = await runAccessibilityCheck(page);
      const landmarkViolation = results.violations.find(
        (v: { id: string }) => v.id === 'landmark-one-main' || v.id === 'region'
      );
      expect(landmarkViolation).toBeUndefined();
    });

    test('@p1 @a11y decision cards should have proper contrast', async ({ page }) => {
      // Given authenticated user on picks page
      await page.goto('/login');
      await page.fill('[data-testid="email"]', 'test@example.com');
      await page.fill('[data-testid="password"]', 'testpassword123');
      await page.click('[data-testid="login-button"]');
      await page.waitForURL(/.*dashboard/);
      await page.goto('/dashboard/picks');

      // Wait for content
      await page.waitForLoadState('networkidle');

      // Run color contrast check
      const results = await runAccessibilityCheck(page, {
        rules: {
          'color-contrast': { enabled: true },
        },
      });

      const contrastViolations = results.violations.filter(
        (v: { id: string }) => v.id === 'color-contrast'
      );

      expect(
        contrastViolations,
        `Found ${contrastViolations.length} color contrast violations`
      ).toHaveLength(0);
    });

    test('@p2 @a11y interactive elements should be keyboard accessible', async ({ page }) => {
      // Given authenticated user
      await page.goto('/login');
      await page.fill('[data-testid="email"]', 'test@example.com');
      await page.fill('[data-testid="password"]', 'testpassword123');
      await page.click('[data-testid="login-button"]');
      await page.waitForURL(/.*dashboard/);

      // Tab through interactive elements
      await page.keyboard.press('Tab');

      // Check that something is focused
      const focusedElement = page.locator(':focus');
      const isFocused = await focusedElement.count() > 0;
      expect(isFocused).toBe(true);

      // Run accessibility scan
      const results = await runAccessibilityCheck(page);
      const focusViolations = results.violations.filter(
        (v: { id: string }) =>
          v.id === 'keyboard-accessibility' ||
          v.id === 'focus-order' ||
          v.id === 'tabindex'
      );

      expect(focusViolations).toHaveLength(0);
    });
  });

  test.describe('Form Accessibility', () => {
    test('@p1 @a11y all form inputs should have associated labels', async ({ page }) => {
      // Given login page (has forms)
      await page.goto('/login');

      // Get all form inputs
      const inputs = page.locator('input, select, textarea');
      const count = await inputs.count();

      for (let i = 0; i < count; i++) {
        const input = inputs.nth(i);
        const inputType = await input.getAttribute('type');

        // Skip hidden inputs
        if (inputType === 'hidden') continue;

        // Check for label association
        const id = await input.getAttribute('id');
        const ariaLabel = await input.getAttribute('aria-label');
        const ariaLabelledBy = await input.getAttribute('aria-labelledby');
        const placeholder = await input.getAttribute('placeholder');

        // Must have one of: label, aria-label, aria-labelledby, or title
        const hasLabel = id && (await page.locator(`label[for="${id}"]`).count()) > 0;
        const hasAccessibleName = ariaLabel || ariaLabelledBy || placeholder;

        expect(
          hasLabel || hasAccessibleName,
          `Input ${await input.evaluate((el: Element) => el.outerHTML)} must have an accessible name`
        ).toBeTruthy();
      }
    });

    test('@p2 @a11y error messages should be associated with inputs', async ({ page }) => {
      // Given login page
      await page.goto('/login');

      // Submit form with empty fields to trigger errors
      await page.click('[data-testid="login-button"]');

      // Wait for potential error messages
      await page.waitForTimeout(500);

      // Check for error messages with proper ARIA
      const errorMessages = page.locator('[role="alert"], [aria-live="assertive"], .error-message');
      const count = await errorMessages.count();

      if (count > 0) {
        for (let i = 0; i < count; i++) {
          const error = errorMessages.nth(i);

          // Error should have aria-describedby pointing to input or aria-errormessage
          const hasProperAria = await error.evaluate((el: Element) => {
            const id = el.id;
            if (!id) return false;

            // Check if any input references this error
            const inputs = document.querySelectorAll(`[aria-describedby*="${id}"], [aria-errormessage*="${id}"]`);
            return inputs.length > 0;
          });

          expect(hasProperAria).toBe(true);
        }
      }
    });
  });

  test.describe('Image Accessibility', () => {
    test('@p2 @a11y all images should have alt text', async ({ page }) => {
      // Given authenticated user on dashboard
      await page.goto('/login');
      await page.fill('[data-testid="email"]', 'test@example.com');
      await page.fill('[data-testid="password"]', 'testpassword123');
      await page.click('[data-testid="login-button"]');
      await page.waitForURL(/.*dashboard/);

      // Check all images
      const images = page.locator('img');
      const count = await images.count();

      for (let i = 0; i < count; i++) {
        const img = images.nth(i);
        const alt = await img.getAttribute('alt');
        const ariaLabel = await img.getAttribute('aria-label');
        const role = await img.getAttribute('role');

        // Images must have alt text OR be marked as decorative (role="presentation" or alt="")
        const isDecorative = role === 'presentation' || alt === '';
        const hasAlt = alt !== null && alt !== '';
        const hasAriaLabel = ariaLabel !== null && ariaLabel !== '';

        expect(
          hasAlt || hasAriaLabel || isDecorative,
          'Images must have alt text or be marked as decorative'
        ).toBeTruthy();
      }
    });
  });

  test.describe('Focus Management', () => {
    test('@p2 @a11y focus indicator should be visible', async ({ page }) => {
      // Given login page
      await page.goto('/login');

      // Tab to first interactive element
      await page.keyboard.press('Tab');

      // Check that focused element has visible outline
      const focusedElement = page.locator(':focus');
      const styles = await focusedElement.evaluate((el: Element) => {
        const computed = window.getComputedStyle(el);
        return {
          outlineWidth: computed.outlineWidth,
          outlineStyle: computed.outlineStyle,
          outlineColor: computed.outlineColor,
        };
      });

      // Focus outline should be visible
      expect(styles.outlineWidth).not.toBe('0px');
      expect(styles.outlineStyle).not.toBe('none');
    });
  });

  test.describe.skip('Accessibility Violations Report', () => {
    test('@p1 @a11y generate full accessibility report', async ({ page }) => {
      // Given authenticated user
      await page.goto('/login');
      await page.fill('[data-testid="email"]', 'test@example.com');
      await page.fill('[data-testid="password"]', 'testpassword123');
      await page.click('[data-testid="login-button"]');
      await page.waitForURL(/.*dashboard/);

      // Run comprehensive accessibility scan
      const results = await runAccessibilityCheck(page);

      // Log all violations for reporting
      console.log('=== Accessibility Report ===');
      console.log(`Total Violations: ${results.violations.length}`);
      console.log(`Total Incomplete: ${results.incomplete.length}`);

      results.violations.forEach((violation: any) => {
        console.log(`\n[${violation.impact.toUpperCase()}] ${violation.id}`);
        console.log(`  Description: ${violation.description}`);
        console.log(`  Help: ${violation.help}`);
        console.log(`  Help URL: ${violation.helpUrl}`);
        console.log(`  Affected nodes: ${violation.nodes.length}`);
      });

      // Fail test if critical violations exist
      const criticalViolations = results.violations.filter(
        (v: { impact: string }) => v.impact === 'critical'
      );

      expect(
        criticalViolations,
        `${criticalViolations.length} critical accessibility violations found`
      ).toHaveLength(0);
    });
  });
});

/**
 * Test execution commands:
 *
 * Run all accessibility tests:
 *   npx playwright test tests/e2e/accessibility.spec.ts
 *
 * Run critical accessibility tests only:
 *   npx playwright test --grep "@p0 @a11y"
 *
 * Run accessibility regression:
 *   npx playwright test --grep "@a11y @regression"
 *
 * Run specific accessibility checks:
 *   npx playwright test --grep "@a11y:contrast"
 *   npx playwright test --grep "@a11y:keyboard"
 *   npx playwright test --grep "@a11y:forms"
 */
