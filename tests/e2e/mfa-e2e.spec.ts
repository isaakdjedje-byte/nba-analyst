/**
 * MFA E2E Tests
 * End-to-end tests for Multi-Factor Authentication user flows
 *
 * Generated by BMAD testarch-automate workflow
 * Priority: P0 (Security-Critical)
 * Test IDs: MFA-E2E-001 through MFA-E2E-010
 */

import { test, expect } from '@playwright/test';
import { TOTP } from 'totp-generator';

const BASE_URL = process.env.BASE_URL || 'http://localhost:3000';

// Test MFA secret - would be set up by test fixtures in real scenario
const TEST_MFA_SECRET = 'JBSWY3DPEHPK3PXP'; // Standard test secret

/**
 * Generate a valid TOTP code for testing
 */
async function generateTOTPCode(secret: string = TEST_MFA_SECRET): Promise<string> {
  const totp = await TOTP.generate(secret, {
    digits: 6,
    period: 30,
    algorithm: 'SHA-1',
  });
  return totp.otp;
}

test.describe('MFA E2E Flows @e2e @mfa @security', () => {
  
  // ==========================================
  // MFA Verification Flow (/login/mfa)
  // ==========================================
  
  test.describe('MFA Verification During Login', () => {
    test('[P0] [MFA-E2E-001] should prompt for MFA after successful password login', async ({ page }) => {
      // Given: User with MFA enabled has entered valid credentials
      // When: Navigate to MFA verification page
      await page.goto(`${BASE_URL}/login/mfa?callbackUrl=/dashboard`);

      // Then: MFA verification form should be displayed
      await expect(page.getByRole('heading', { name: /two.factor|multi.factor|mfa/i })).toBeVisible();
      await expect(page.getByRole('textbox', { name: /code|token/i })).toBeVisible();
      await expect(page.getByRole('button', { name: /verify|submit/i })).toBeVisible();
    });

    test('[P0] [MFA-E2E-002] should complete login with valid MFA code', async ({ page }) => {
      // Given: User on MFA verification page with valid session
      await page.goto(`${BASE_URL}/login/mfa`);
      
      // When: Enter valid TOTP code and submit
      const validCode = await generateTOTPCode();
      await page.getByRole('textbox', { name: /code|token/i }).fill(validCode);
      await page.getByRole('button', { name: /verify|submit/i }).click();

      // Then: Should redirect to callback URL or dashboard
      // Note: This may fail if no valid session exists - requires test setup
      await expect(page).toHaveURL(/dashboard|login/);
    });

    test('[P0] [MFA-E2E-003] should show error for invalid MFA code', async ({ page }) => {
      // Given: User on MFA verification page
      await page.goto(`${BASE_URL}/login/mfa`);
      
      // When: Enter invalid MFA code (not a valid TOTP)
      await page.getByRole('textbox', { name: /code|token/i }).fill('000000');
      await page.getByRole('button', { name: /verify|submit/i }).click();

      // Then: Should show error message
      await expect(page.getByText(/invalid|incorrect|wrong/i)).toBeVisible();
      // And: Should stay on MFA page
      await expect(page).toHaveURL(/login\/mfa/);
    });

    test('[P1] [MFA-E2E-004] should handle backup code option', async ({ page }) => {
      // Given: User on MFA verification page
      await page.goto(`${BASE_URL}/login/mfa`);
      
      // When: Click "Use backup code" option
      const backupCodeLink = page.getByRole('button', { name: /Use backup code/i });
      await expect(backupCodeLink).toBeVisible();
      await backupCodeLink.click();
      
      // Then: Should show backup code input with 8-character placeholder
      const codeInput = page.getByRole('textbox', { name: /Backup Code/i });
      await expect(codeInput).toBeVisible();
      await expect(codeInput).toHaveAttribute('maxLength', '8');
      
      // And: Button should switch back to authenticator option
      await expect(page.getByRole('button', { name: /Use authenticator app code/i })).toBeVisible();
    });

    test('[P1] [MFA-E2E-005] should redirect back to original destination after MFA', async ({ page }) => {
      // Given: User tried to access protected page
      const protectedUrl = '/admin/users';
      await page.goto(`${BASE_URL}/login/mfa?callbackUrl=${encodeURIComponent(protectedUrl)}`);
      
      // When: Complete MFA verification
      await page.getByRole('textbox', { name: /code|token/i }).fill('123456');
      await page.getByRole('button', { name: /verify|submit/i }).click();

      // Then: Should redirect to originally requested page
      await expect(page).toHaveURL(/admin\/users/);
    });
  });

  // ==========================================
  // MFA Setup Flow (/settings/mfa)
  // ==========================================
  
  test.describe('MFA Setup in Settings', () => {
    test('[P0] [MFA-E2E-006] should display MFA setup page', async ({ page }) => {
      // Given: Authenticated user
      await page.goto(`${BASE_URL}/settings/mfa`);

      // Then: MFA settings page should load
      await expect(page.getByRole('heading', { name: /two.factor|multi.factor|mfa/i })).toBeVisible();
    });

    test('[P0] [MFA-E2E-007] should initiate MFA setup process', async ({ page }) => {
      // Given: User on MFA settings page
      await page.goto(`${BASE_URL}/settings/mfa/setup`);

      // Then: Setup wizard should be displayed
      await expect(page.getByRole('heading', { name: /setup|enable/i })).toBeVisible();
      // QR code for authenticator app
      await expect(page.locator('img[alt*="QR"], [data-testid="mfa-qr-code"]')).toBeVisible();
      // Secret key for manual entry
      await expect(page.getByText(/secret|key/i)).toBeVisible();
    });

    test('[P0] [MFA-E2E-008] should complete MFA setup with verification', async ({ page }) => {
      // Given: User on MFA setup page
      await page.goto(`${BASE_URL}/settings/mfa/setup`);

      // When: Enter verification code to confirm setup
      await page.getByRole('textbox', { name: /code|verification/i }).fill('123456');
      await page.getByRole('button', { name: /verify|confirm|enable/i }).click();

      // Then: Should show success message
      await expect(page.getByText(/success|enabled|complete/i)).toBeVisible();
      // And: Should display backup codes
      await expect(page.getByText(/backup|recovery/i)).toBeVisible();
    });

    test('[P1] [MFA-E2E-009] should display backup codes after setup', async ({ page }) => {
      // Given: User completing MFA setup
      await page.goto(`${BASE_URL}/settings/mfa/setup`);
      await page.getByRole('textbox', { name: /code|verification/i }).fill('123456');
      await page.getByRole('button', { name: /verify|confirm/i }).click();

      // Then: Backup codes should be displayed
      await expect(page.getByText(/backup.codes|recovery.codes/i)).toBeVisible();
      // And: Download/Copy buttons should be available
      await expect(page.getByRole('button', { name: /download|copy|save/i })).toBeVisible();
    });

    test('[P1] [MFA-E2E-010] should allow disabling MFA when enabled', async ({ page }) => {
      // Given: User with MFA enabled on settings page
      // Note: This test requires an authenticated user with MFA pre-enabled
      // In a real scenario, use a fixture to ensure MFA is enabled
      await page.goto(`${BASE_URL}/settings/mfa`);

      // When: Click disable MFA (button should be visible if MFA is enabled)
      const disableButton = page.getByRole('button', { name: /disable|turn.off|remove/i });
      await expect(disableButton).toBeVisible({ timeout: 5000 });
      await disableButton.click();

      // Confirm disable
      await page.getByRole('textbox', { name: /confirm|password/i }).fill('password123');
      await page.getByRole('button', { name: /confirm|yes|disable/i }).click();

      // Then: Should show confirmation
      await expect(page.getByText(/disabled|removed/i)).toBeVisible();
    });

    test('[P2] [MFA-E2E-011] should show enable MFA option when MFA is disabled', async ({ page }) => {
      // Given: User with MFA disabled on settings page
      // Note: This test requires an authenticated user with MFA pre-disabled
      await page.goto(`${BASE_URL}/settings/mfa`);

      // Then: Should show option to enable MFA (not disable)
      const enableButton = page.getByRole('button', { name: /enable|setup|configure/i });
      await expect(enableButton).toBeVisible({ timeout: 5000 });
    });
  });
});
