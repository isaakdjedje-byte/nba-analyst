/**
 * Factories Demo
 * Exemples d'utilisation des factories pour créer des données de test
 *
 * Generated by BMAD testarch-framework workflow
 */

import { test, expect } from '../support/merged-fixtures';
import {
  createUser,
  createAdminUser,
  createDecision,
  createNoBetDecision,
  createHardStopDecision,
  createRun,
  createFailedRun,
  createMatch,
} from '../support/factories';

test.describe('Factories Demo', () => {
  test('should create a basic user', async () => {
    // Given a user created via factory
    const user = createUser();

    // Then it should have valid data
    expect(user.id).toBeDefined();
    expect(user.email).toContain('@');
    expect(user.role).toBe('user');
    expect(user.isActive).toBe(true);
    console.log('✅ User created:', user.email);
  });

  test('should create an admin user with overrides', async () => {
    // Given an admin user with specific email
    const admin = createAdminUser({ email: 'admin@test.com' });

    // Then it should have admin role and custom email
    expect(admin.role).toBe('admin');
    expect(admin.email).toBe('admin@test.com');
    console.log('✅ Admin created:', admin.email);
  });

  test('should create a decision with all properties', async () => {
    // Given a decision with Pick status
    const decision = createDecision({ status: 'Pick' });

    // Then it should have all required fields
    expect(decision.id).toBeDefined();
    expect(decision.status).toBe('Pick');
    expect(decision.confidence).toBeGreaterThan(0);
    expect(decision.traceId).toBeDefined();
    expect(decision.policyGates).toBeDefined();
    console.log('✅ Decision created:', decision.id, 'Status:', decision.status);
  });

  test('should create specialized decisions', async () => {
    // Given different types of decisions
    const pick = createDecision();
    const noBet = createNoBetDecision();
    const hardStop = createHardStopDecision();

    // Then each should have correct status
    expect(pick.status).toBe('Pick');
    expect(noBet.status).toBe('No-Bet');
    expect(hardStop.status).toBe('Hard-Stop');

    // And correct policy gates
    expect(hardStop.policyGates.hardStopGate).toBe('failed');
    expect(noBet.policyGates.edgeGate).toBe('failed');

    console.log('✅ Created:', {
      pick: pick.status,
      noBet: noBet.status,
      hardStop: hardStop.status,
    });
  });

  test('should create runs with different statuses', async () => {
    // Given runs in different states
    const completedRun = createRun();
    const failedRun = createFailedRun();
    const runningRun = createRun({ status: 'running' });

    // Then they should have correct statuses
    expect(completedRun.status).toBe('completed');
    expect(failedRun.status).toBe('failed');
    expect(failedRun.errorsCount).toBeGreaterThan(0);
    expect(runningRun.status).toBe('running');

    console.log('✅ Runs created:', {
      completed: completedRun.status,
      failed: failedRun.status,
      running: runningRun.status,
    });
  });

  test('should create matches with realistic data', async () => {
    // Given NBA matches
    const match1 = createMatch();
    const match2 = createMatch({
      homeTeam: 'Lakers',
      awayTeam: 'Warriors',
    });

    // Then they should have valid data
    expect(match1.id).toBeDefined();
    expect(match1.league).toBe('NBA');
    expect(match2.homeTeam).toBe('Lakers');
    expect(match2.awayTeam).toBe('Warriors');

    console.log('✅ Matches:', match1.homeTeam, 'vs', match1.awayTeam);
    console.log('✅ Custom match:', match2.homeTeam, 'vs', match2.awayTeam);
  });

  test('should create complete test scenario', async ({ api }) => {
    // Given a complete scenario with user, match, and decision
    const user = createUser({ email: 'scenario@test.com' });
    const match = createMatch({ homeTeam: 'Lakers', awayTeam: 'Celtics' });
    const decision = createDecision({
      matchId: match.id,
      status: 'Pick',
    });

    // When creating these entities via API
    const userResponse = await api.post('/api/users', user);
    const decisionResponse = await api.post('/api/decisions', decision);

    // Then they should be created successfully
    expect(userResponse.status()).toBe(201);
    expect(decisionResponse.status()).toBe(201);

    const createdDecision = await decisionResponse.json();
    expect(createdDecision.matchId).toBe(match.id);
    expect(createdDecision.status).toBe('Pick');

    console.log('✅ Complete scenario created!');
    console.log('  User:', user.email);
    console.log('  Match:', match.homeTeam, 'vs', match.awayTeam);
    console.log('  Decision:', decision.status);
  });

  test('should demonstrate factory composition', async () => {
    // Given nested factories
    const match = createMatch();
    const user = createUser();

    const decision = createDecision({
      matchId: match.id,
      // Override specific fields
      status: 'Pick',
      confidence: 0.85,
      modelOutputs: {
        winner: match.homeTeam,
        score: '110-105',
        overUnder: 'Over',
      },
    });

    // Then the decision should have all custom values
    expect(decision.matchId).toBe(match.id);
    expect(decision.status).toBe('Pick');
    expect(decision.confidence).toBe(0.85);
    expect(decision.modelOutputs.winner).toBe(match.homeTeam);

    console.log('✅ Composed decision:', {
      match: `${match.homeTeam} vs ${match.awayTeam}`,
      winner: decision.modelOutputs.winner,
      confidence: decision.confidence,
    });
  });

  test('should handle multiple parallel-safe users', async () => {
    // Given multiple users (safe for parallel execution due to UUIDs)
    const users = Array.from({ length: 5 }, () => createUser());

    // Then each should have unique ID and email
    const ids = users.map((u) => u.id);
    const emails = users.map((u) => u.email);

    expect(new Set(ids).size).toBe(5); // All unique
    expect(new Set(emails).size).toBe(5); // All unique

    console.log('✅ Created', users.length, 'unique users');
    console.log('  IDs:', ids);
  });
});
