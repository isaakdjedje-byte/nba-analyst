/**
 * Factories Demo
 * Exemples d'utilisation des factories pour créer des données de test
 *
 * Generated by BMAD testarch-framework workflow
 * Priority: P2 (Medium)
 * Test IDs: 1.3-FACT-001 through 1.3-FACT-009
 */

import { test, expect } from '@playwright/test';
import {
  createUser,
  createAdminUser,
  createDecision,
  createNoBetDecision,
  createHardStopDecision,
  createRun,
  createFailedRun,
  createMatch,
} from '../support/factories';

test.describe('Factories Demo - P2 @p2 @factories @demo', () => {
  const baseUrl = process.env.BASE_URL || 'http://localhost:3000';
  const createdUserIds: string[] = [];

  test.afterEach(async ({ request }) => {
    // Cleanup: Delete all users created during test
    for (const userId of createdUserIds) {
      await request.delete(`${baseUrl}/api/users?id=${userId}`).catch(() => {});
    }
    createdUserIds.length = 0;
  });

  test('[P2] [1.3-FACT-001] should create a basic user', async () => {
    // Given a user created via factory
    const user = createUser();

    // Then it should have valid data
    expect(user.id).toBeDefined();
    expect(user.email).toContain('@');
    expect(user.role).toBe('user');
    expect(user.isActive).toBe(true);
    // User created: user.email
  });

  test('[P2] [1.3-FACT-002] should create an admin user with overrides', async () => {
    // Given an admin user with specific email
    const admin = createAdminUser({ email: 'admin@test.com' });

    // Then it should have admin role and custom email
    expect(admin.role).toBe('admin');
    expect(admin.email).toBe('admin@test.com');
  });

  test('[P2] [1.3-FACT-003] should create a decision with all properties', async () => {
    // Given a decision with Pick status
    const decision = createDecision({ status: 'Pick' });

    // Then it should have all required fields
    expect(decision.id).toBeDefined();
    expect(decision.status).toBe('Pick');
    expect(decision.confidence).toBeGreaterThan(0);
    expect(decision.traceId).toBeDefined();
    expect(decision.policyGates).toBeDefined();
  });

  test('[P2] [1.3-FACT-004] should create specialized decisions', async () => {
    // Given different types of decisions
    const pick = createDecision();
    const noBet = createNoBetDecision();
    const hardStop = createHardStopDecision();

    // Then each should have correct status
    expect(pick.status).toBe('Pick');
    expect(noBet.status).toBe('No-Bet');
    expect(hardStop.status).toBe('Hard-Stop');

    // And correct policy gates
    expect(hardStop.policyGates.hardStopGate).toBe('failed');
    expect(noBet.policyGates.edgeGate).toBe('failed');
  });

  test('[P2] [1.3-FACT-005] should create runs with different statuses', async () => {
    // Given runs in different states
    const completedRun = createRun();
    const failedRun = createFailedRun();
    const runningRun = createRun({ status: 'running' });

    // Then they should have correct statuses
    expect(completedRun.status).toBe('completed');
    expect(failedRun.status).toBe('failed');
    expect(failedRun.errorsCount).toBeGreaterThan(0);
    expect(runningRun.status).toBe('running');
  });

  test('[P2] [1.3-FACT-006] should create matches with realistic data', async () => {
    // Given NBA matches
    const match1 = createMatch();
    const match2 = createMatch({
      homeTeam: 'Lakers',
      awayTeam: 'Warriors',
    });

    // Then they should have valid data
    expect(match1.id).toBeDefined();
    expect(match1.league).toBe('NBA');
    expect(match2.homeTeam).toBe('Lakers');
    expect(match2.awayTeam).toBe('Warriors');
  });

  test('[P2] [1.3-FACT-007] should create complete test scenario via API', async ({ request }) => {
    // Given a complete scenario with user, match, and decision
    const user = createUser({ email: 'scenario@test.com' });
    const match = createMatch({ homeTeam: 'Lakers', awayTeam: 'Celtics' });
    const decision = createDecision({
      matchId: match.id,
      status: 'Pick',
    });

    // When creating user via API (send only API-compatible fields)
    const userResponse = await request.post(`${baseUrl}/api/users`, {
      data: {
        email: user.email,
        name: user.name,
        role: user.role,
      }
    });

    // Then they should be created successfully
    expect(userResponse.status()).toBe(201);
    const createdUser = await userResponse.json();
    expect(createdUser.email).toBe(user.email);

    // Track for cleanup
    createdUserIds.push(createdUser.id);
  });

  test('[P2] [1.3-FACT-008] should demonstrate factory composition', async () => {
    // Given nested factories
    const match = createMatch();
    const user = createUser();

    const decision = createDecision({
      matchId: match.id,
      // Override specific fields
      status: 'Pick',
      confidence: 0.85,
      modelOutputs: {
        winner: match.homeTeam,
        score: '110-105',
        overUnder: 'Over',
      },
    });

    // Then the decision should have all custom values
    expect(decision.matchId).toBe(match.id);
    expect(decision.status).toBe('Pick');
    expect(decision.confidence).toBe(0.85);
    expect(decision.modelOutputs.winner).toBe(match.homeTeam);
  });

  test('[P2] [1.3-FACT-009] should handle multiple parallel-safe users', async () => {
    // Given multiple users (safe for parallel execution due to UUIDs)
    const users = Array.from({ length: 5 }, () => createUser());

    // Then each should have unique ID and email
    const ids = users.map((u) => u.id);
    const emails = users.map((u) => u.email);

    expect(new Set(ids).size).toBe(5); // All unique
    expect(new Set(emails).size).toBe(5); // All unique
  });
});
