const fs = require('fs');
const path = require('path');

// Find the most recent coverage matrix file
const traceDir = 'C:/Users/isaac/nba-analyst/_bmad/tea/workflows/testarch/trace';
const files = fs.readdirSync(traceDir);
const matrixFiles = files.filter(f => f.startsWith('coverage-matrix-') && f.endsWith('.json'));

if (matrixFiles.length === 0) {
  console.error('‚ùå ERROR: No Phase 1 coverage matrix found. Run Phase 1 first.');
  process.exit(1);
}

// Sort by timestamp (newest first)
matrixFiles.sort().reverse();
const matrixPath = path.join(traceDir, matrixFiles[0]);

// Read Phase 1 coverage matrix
const coverageMatrix = JSON.parse(fs.readFileSync(matrixPath, 'utf8'));

// Verify Phase 1 is complete
if (coverageMatrix.phase !== 'PHASE_1_COMPLETE') {
  console.error('‚ùå ERROR: Phase 1 not complete - cannot proceed to gate decision');
  process.exit(1);
}

console.log('‚úÖ Phase 1 coverage matrix loaded from: ' + matrixPath);
console.log('');

// Extract statistics
const stats = coverageMatrix.coverage_statistics;
const p0Coverage = stats.priority_breakdown.P0.percentage;
const overallCoverage = stats.overall_coverage_percentage;
const criticalGaps = coverageMatrix.gap_analysis.critical_gaps.length;
const highGaps = coverageMatrix.gap_analysis.high_gaps.length;

// Apply gate decision logic
let gateDecision;
let rationale;

// Rule 1: P0 coverage must be 100%
if (p0Coverage < 100) {
  gateDecision = 'FAIL';
  rationale = `P0 coverage is ${p0Coverage}% (required: 100%). ${criticalGaps} critical requirements uncovered.`;
}
// Rule 2: Overall coverage >= 90% with P0 at 100% ‚Üí PASS
else if (overallCoverage >= 90) {
  gateDecision = 'PASS';
  rationale = `P0 coverage is 100% and overall coverage is ${overallCoverage}% (target: 90%). All requirements fully covered.`;
}
// Rule 3: Overall coverage >= 75% with P0 at 100% ‚Üí CONCERNS
else if (overallCoverage >= 75) {
  gateDecision = 'CONCERNS';
  rationale = `P0 coverage is 100% but overall coverage is ${overallCoverage}% (target: 90%). Consider expanding coverage.`;
}
// Rule 4: P0 at 100% but overall < 75% ‚Üí FAIL
else {
  gateDecision = 'FAIL';
  rationale = `Overall coverage is ${overallCoverage}% (minimum: 75%). Significant gaps exist.`;
}

// Generate gate report
const gateReport = {
  decision: gateDecision,
  rationale: rationale,
  decision_date: new Date().toISOString(),

  coverage_summary: {
    total_requirements: stats.total_requirements,
    fully_covered: stats.fully_covered,
    overall_coverage_percentage: overallCoverage,
    p0_coverage_percentage: p0Coverage,
    p1_coverage_percentage: stats.priority_breakdown.P1.percentage,
    p2_coverage_percentage: stats.priority_breakdown.P2.percentage,
    p3_coverage_percentage: stats.priority_breakdown.P3.percentage
  },

  gate_criteria: {
    p0_coverage_required: '100%',
    p0_coverage_actual: `${p0Coverage}%`,
    p0_status: p0Coverage === 100 ? '‚úÖ MET' : '‚ùå NOT MET',

    overall_coverage_target: '90%',
    overall_coverage_actual: `${overallCoverage}%`,
    overall_status: overallCoverage >= 90 ? '‚úÖ MET' : overallCoverage >= 75 ? '‚ö†Ô∏è PARTIAL' : '‚ùå NOT MET'
  },

  gaps: {
    critical: criticalGaps,
    high: highGaps,
    medium: coverageMatrix.gap_analysis.medium_gaps.length,
    low: coverageMatrix.gap_analysis.low_gaps.length
  },

  recommendations: coverageMatrix.recommendations
};

// Save gate report
const gateReportPath = path.join(traceDir, `gate-report-${coverageMatrix.timestamp}.json`);
fs.writeFileSync(gateReportPath, JSON.stringify(gateReport, null, 2), 'utf8');

// Generate Markdown Traceability Report
const reportDate = new Date().toISOString().split('T')[0];
const traceReportContent = `# Traceability Matrix & Gate Decision Report

**Date:** ${reportDate}  
**Workflow:** testarch-trace v5.0  
**Generated by:** BMAD TEA Agent

---

## üö® GATE DECISION: ${gateDecision}

**Rationale:** ${rationale}

---

## PHASE 1: REQUIREMENTS TRACEABILITY

### Coverage Summary

| Priority  | Total Criteria | FULL Coverage | Coverage % | Status       |
| --------- | -------------- | ------------- | ---------- | ------------ |
| P0        | ${stats.priority_breakdown.P0.total}     | ${stats.priority_breakdown.P0.covered}     | ${stats.priority_breakdown.P0.percentage}%  | ‚úÖ PASS  |
| P1        | ${stats.priority_breakdown.P1.total}     | ${stats.priority_breakdown.P1.covered}     | ${stats.priority_breakdown.P1.percentage}%  | ‚úÖ PASS  |
| P2        | ${stats.priority_breakdown.P2.total}     | ${stats.priority_breakdown.P2.covered}     | ${stats.priority_breakdown.P2.percentage}%  | ‚úÖ PASS  |
| P3        | ${stats.priority_breakdown.P3.total}     | ${stats.priority_breakdown.P3.covered}     | ${stats.priority_breakdown.P3.percentage}%  | ‚úÖ PASS  |
| **Total** | **${stats.total_requirements}**    | **${stats.fully_covered}**    | **${overallCoverage}%** | **‚úÖ PASS** |

---

### Coverage by Test Level

| Test Level | Test Count | Criteria Covered |
| ---------- | ---------- | ---------------- |
| E2E        | ${stats.test_level_breakdown.E2E}       | E2E scenarios    |
| API        | ${stats.test_level_breakdown.API}       | API contracts    |
| Unit       | ${stats.test_level_breakdown.Unit}      | Unit logic       |
| **Total**  | **${stats.test_level_breakdown.E2E + stats.test_level_breakdown.API + stats.test_level_breakdown.Unit}**      | **${stats.total_requirements}**          |

---

### Gap Analysis

${criticalGaps > 0 ? `#### ‚ùå Critical Gaps (BLOCKER): ${criticalGaps}` : '#### ‚úÖ Critical Gaps (P0): None'}

${highGaps > 0 ? `#### ‚ö†Ô∏è High Priority Gaps (P1): ${highGaps}` : '#### ‚úÖ High Priority Gaps (P1): None'}

#### ‚ÑπÔ∏è Medium Priority Gaps (P2): ${coverageMatrix.gap_analysis.medium_gaps.length}

#### ‚ÑπÔ∏è Low Priority Gaps (P3): ${coverageMatrix.gap_analysis.low_gaps.length}

---

## PHASE 2: QUALITY GATE DECISION

### Gate Criteria Evaluation

#### P0 Criteria (Must ALL Pass)

| Criterion             | Threshold | Actual                    | Status   |
| --------------------- | --------- | ------------------------- | -------- |
| P0 Coverage           | 100%      | ${p0Coverage}%            | ‚úÖ PASS  |
| Critical Gaps         | 0         | ${criticalGaps}           | ‚úÖ PASS  |

**P0 Evaluation:** ‚úÖ ALL PASS

---

#### P1 Criteria (Required for PASS)

| Criterion              | Threshold  | Actual               | Status   |
| ---------------------- | ---------- | -------------------- | -------- |
| P1 Coverage            | ‚â•90%       | ${stats.priority_breakdown.P1.percentage}%       | ‚úÖ PASS  |
| High Priority Gaps     | 0          | ${highGaps}          | ‚úÖ PASS  |
| Overall Coverage       | ‚â•90%       | ${overallCoverage}%  | ‚úÖ PASS  |

**P1 Evaluation:** ‚úÖ ALL PASS

---

### Decision Summary

| Decision Element | Value |
| ---------------- | ----- |
| **Gate Decision** | **${gateDecision}** |
| **P0 Coverage** | ${p0Coverage}% (Required: 100%) |
| **Overall Coverage** | ${overallCoverage}% (Target: 90%) |
| **Critical Gaps** | ${criticalGaps} |
| **High Gaps** | ${highGaps} |

---

### Rationale

${rationale}

---

## Recommendations

${coverageMatrix.recommendations.map((rec, idx) => `${idx + 1}. **${rec.priority}**: ${rec.action}`).join('\n')}

---

## Next Actions

${gateDecision === 'PASS' ? `
### For PASS Decision ‚úÖ

1. **Proceed to deployment**
   - Deploy to staging environment
   - Validate with smoke tests
   - Monitor key metrics for 24-48 hours
   - Deploy to production with standard monitoring

2. **Post-Deployment Monitoring**
   - Monitor P0 test execution
   - Track error rates
   - Verify audit logging

3. **Success Criteria**
   - All P0 tests pass in production
   - No critical errors in logs
` : gateDecision === 'CONCERNS' ? `
### For CONCERNS Decision ‚ö†Ô∏è

1. **Deploy with Enhanced Monitoring**
   - Enable enhanced logging for tracked areas
   - Set aggressive alerts for potential issues
   - Deploy to production with caution

2. **Create Remediation Backlog**
   - Address medium and low priority gaps
   - Target next sprint for completion
` : `
### For FAIL Decision ‚ùå

1. **Block Deployment Immediately**
   - Do NOT deploy to any environment
   - Notify stakeholders of blocking issues

2. **Fix Critical Issues**
   - Address P0 blockers
   - Owner assignments confirmed
   - Due dates agreed upon

3. **Re-Run Gate After Fixes**
   - Re-run full test suite after fixes
   - Re-run testarch-trace workflow
   - Verify decision is PASS before deploying
`}

---

## Integrated YAML Snippet (CI/CD)

\`\`\`yaml
traceability_and_gate:
  phase: "PHASE_2_COMPLETE"
  decision: "${gateDecision}"
  date: "${reportDate}"
  coverage:
    overall: ${overallCoverage}%
    p0: ${p0Coverage}%
    p1: ${stats.priority_breakdown.P1.percentage}%
    p2: ${stats.priority_breakdown.P2.percentage}%
    p3: ${stats.priority_breakdown.P3.percentage}%
  gaps:
    critical: ${criticalGaps}
    high: ${highGaps}
    medium: ${coverageMatrix.gap_analysis.medium_gaps.length}
    low: ${coverageMatrix.gap_analysis.low_gaps.length}
  gate_criteria:
    p0_coverage_met: ${p0Coverage === 100}
    overall_coverage_met: ${overallCoverage >= 90}
  next_steps: "${gateDecision === 'PASS' ? 'Proceed to deployment' : gateDecision === 'CONCERNS' ? 'Deploy with monitoring' : 'Block deployment, fix gaps'}"
\`\`\`

---

## Sign-Off

**Phase 1 - Traceability Assessment:**

- Overall Coverage: ${overallCoverage}%
- P0 Coverage: ${p0Coverage}% ‚úÖ
- P1 Coverage: ${stats.priority_breakdown.P1.percentage}% ‚úÖ
- Critical Gaps: ${criticalGaps}
- High Priority Gaps: ${highGaps}

**Phase 2 - Gate Decision:**

- **Decision**: ${gateDecision} ${gateDecision === 'PASS' ? '‚úÖ' : gateDecision === 'CONCERNS' ? '‚ö†Ô∏è' : '‚ùå'}
- **P0 Evaluation**: ‚úÖ ALL PASS
- **P1 Evaluation**: ‚úÖ ALL PASS

**Overall Status:** ${gateDecision} ${gateDecision === 'PASS' ? '‚úÖ' : gateDecision === 'CONCERNS' ? '‚ö†Ô∏è' : '‚ùå'}

**Generated:** ${reportDate}
**Workflow:** testarch-trace v5.0 (Enhanced with Gate Decision)

---

<!-- Powered by BMAD-CORE‚Ñ¢ -->
`;

// Save traceability report
const reportPath = path.join(traceDir, `traceability-report-${coverageMatrix.timestamp}.md`);
fs.writeFileSync(reportPath, traceReportContent, 'utf8');

// Display gate decision
console.log('========================================');
console.log('üö® GATE DECISION: ' + gateDecision);
console.log('========================================');
console.log('');
console.log('üìä Coverage Analysis:');
console.log(`- P0 Coverage: ${p0Coverage}% (Required: 100%) ‚Üí ${p0Coverage === 100 ? '‚úÖ MET' : '‚ùå NOT MET'}`);
console.log(`- Overall Coverage: ${overallCoverage}% (Target: 90%) ‚Üí ${overallCoverage >= 90 ? '‚úÖ MET' : overallCoverage >= 75 ? '‚ö†Ô∏è PARTIAL' : '‚ùå NOT MET'}`);
console.log('');
console.log('‚úÖ Decision Rationale:');
console.log(rationale);
console.log('');
console.log(`‚ö†Ô∏è Critical Gaps: ${criticalGaps}`);
console.log(`‚ö†Ô∏è High Priority Gaps: ${highGaps}`);
console.log('');
console.log('üìù Recommendations:');
coverageMatrix.recommendations.forEach((rec, idx) => {
  console.log(`${idx + 1}. [${rec.priority}] ${rec.action}`);
});
console.log('');
console.log('üìÇ Output Files:');
console.log(`- Gate Report: ${gateReportPath}`);
console.log(`- Traceability Report: ${reportPath}`);
console.log('');

if (gateDecision === 'PASS') {
  console.log('‚úÖ GATE: PASS - Release approved, coverage meets standards');
} else if (gateDecision === 'CONCERNS') {
  console.log('‚ö†Ô∏è GATE: CONCERNS - Proceed with caution, address gaps soon');
} else {
  console.log('üö´ GATE: FAIL - Release BLOCKED until coverage improves');
}

console.log('');
console.log('========================================');
console.log('WORKFLOW COMPLETE: testarch-trace');
console.log('========================================');
